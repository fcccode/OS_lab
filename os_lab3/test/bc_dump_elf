
build/usr/bc.bin.elf:     file format elf32-i386


Disassembly of section .text:

0000a100 <_start>:
    a100:	66 e8 5b 09          	callw  aa5f <_Z6strtolPKcPPci+0x1a7>
    a104:	00 00                	add    %al,(%eax)
    a106:	b4 4c                	mov    $0x4c,%ah
    a108:	cd 21                	int    $0x21

0000a10a <_Z7isspacei>:
namespace hhlibc {

#endif

int isspace( int ch )
{
    a10a:	66 55                	push   %bp
    a10c:	66 89 e5             	mov    %sp,%bp
    a10f:	67 66 8b 55 08       	mov    0x8(%di),%dx
    return (ch == 9 || ch == 32 || (ch >= 10 && ch <= 13));
    a114:	67 66 8d 42 f7       	lea    -0x9(%bp,%si),%ax
    a119:	66 83 f8 04          	cmp    $0x4,%ax
    a11d:	0f 96 c0             	setbe  %al
    a120:	66 83 fa 20          	cmp    $0x20,%dx
    a124:	0f 94 c2             	sete   %dl
    a127:	66 09 d0             	or     %dx,%ax
    a12a:	66 0f b6 c0          	movzbw %al,%ax
}
    a12e:	66 5d                	pop    %bp
    a130:	66 c3                	retw   

0000a132 <_Z7isalnumi>:

int isalnum(int ch)
{
    a132:	66 55                	push   %bp
    a134:	66 89 e5             	mov    %sp,%bp
    a137:	67 66 8b 55 08       	mov    0x8(%di),%dx
    return ((ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122));
    a13c:	67 66 8d 4a d0       	lea    -0x30(%bp,%si),%cx
    a141:	b0 01                	mov    $0x1,%al
    a143:	66 83 f9 09          	cmp    $0x9,%cx
    a147:	76 0f                	jbe    a158 <_Z7isalnumi+0x26>
    a149:	66 83 e2 df          	and    $0xffdf,%dx
    a14d:	66 83 ea 41          	sub    $0x41,%dx
    a151:	66 83 fa 19          	cmp    $0x19,%dx
    a155:	0f 96 c0             	setbe  %al
    a158:	66 0f b6 c0          	movzbw %al,%ax
}
    a15c:	66 5d                	pop    %bp
    a15e:	66 c3                	retw   

0000a160 <_Z7isdigiti>:

int isdigit(int ch)
{
    a160:	66 55                	push   %bp
    a162:	66 89 e5             	mov    %sp,%bp
    return (ch >= 48 && ch <= 57);
    a165:	67 66 8b 45 08       	mov    0x8(%di),%ax
    a16a:	66 83 e8 30          	sub    $0x30,%ax
    a16e:	66 83 f8 09          	cmp    $0x9,%ax
    a172:	0f 96 c0             	setbe  %al
    a175:	66 0f b6 c0          	movzbw %al,%ax
}
    a179:	66 5d                	pop    %bp
    a17b:	66 c3                	retw   

0000a17d <_ZL19system_call_putchari>:
    int mask = 0x00FF;
    ret = ret & mask;
    return ret;
}
static inline void system_call_putchar(int ch)
{
    a17d:	66 55                	push   %bp
    a17f:	66 89 e5             	mov    %sp,%bp
    a182:	66 53                	push   %bx
    a184:	66 89 c2             	mov    %ax,%dx
            "movw %%bx, %%es\n\t"

    :
    :"r"(c)
    :"%eax", "ebx"
    );
    a187:	88 d0                	mov    %dl,%al
    a189:	b4 01                	mov    $0x1,%ah
    a18b:	8c d3                	mov    %ss,%ebx
    a18d:	8e e3                	mov    %ebx,%fs
    a18f:	bb 00 00 8e d3       	mov    $0xd38e0000,%ebx
    a194:	8e db                	mov    %ebx,%ds
    a196:	8e c3                	mov    %ebx,%es
    a198:	cd 98                	int    $0x98
    a19a:	8c e3                	mov    %fs,%ebx
    a19c:	8e d3                	mov    %ebx,%ss
    a19e:	8e db                	mov    %ebx,%ds
    a1a0:	8e c3                	mov    %ebx,%es
}
    a1a2:	66 5b                	pop    %bx
    a1a4:	66 5d                	pop    %bp
    a1a6:	66 c3                	retw   

0000a1a8 <_Z7putchari>:
namespace hhlibc {

#endif
#ifndef _HHOS_LIBC_TEST
int putchar( int ch )
{
    a1a8:	66 55                	push   %bp
    a1aa:	66 89 e5             	mov    %sp,%bp
    a1ad:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    //sys_get_current_tty()->putchar(ch);
    system_call_putchar(ch);
    a1b2:	66 89 c8             	mov    %cx,%ax
    a1b5:	66 e8 c2 ff          	callw  a17b <_Z7isdigiti+0x1b>
    a1b9:	ff                   	(bad)  
    a1ba:	ff 66 89             	jmp    *-0x77(%esi)
    //sys_tty_putchar(ch);
    return ch;
}
    a1bd:	c8 66 5d 66          	enter  $0x5d66,$0x66
    a1c1:	c3                   	ret    

0000a1c2 <_Z4putsPKc>:

int puts(const char* string)
{
    a1c2:	66 55                	push   %bp
    a1c4:	66 89 e5             	mov    %sp,%bp
    a1c7:	66 53                	push   %bx
    a1c9:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    auto len = strlen(string);
    a1ce:	66 53                	push   %bx
    a1d0:	66 e8 81 05          	callw  a755 <_Z6memsetPvim+0x23>
    a1d4:	00 00                	add    %al,(%eax)
    a1d6:	66 89 d9             	mov    %bx,%cx
    a1d9:	67 66 8d 1c          	lea    (%si),%bx
    a1dd:	03 66 58             	add    0x58(%esi),%esp
    for(size_t i = 0; i < len; ++i)
    a1e0:	66 39 d9             	cmp    %bx,%cx
    a1e3:	74 0f                	je     a1f4 <_Z4putsPKc+0x32>
    {
        putchar(*(string + i));
    a1e5:	67 66 0f be 01       	movsbw (%bx,%di),%ax
    system_call_putchar(ch);
    a1ea:	66 e8 8d ff          	callw  a17b <_Z7isdigiti+0x1b>
    a1ee:	ff                   	(bad)  
    a1ef:	ff 66 41             	jmp    *0x41(%esi)
    for(size_t i = 0; i < len; ++i)
    a1f2:	eb ec                	jmp    a1e0 <_Z4putsPKc+0x1e>
    }
    return 0;
}
    a1f4:	66 31 c0             	xor    %ax,%ax
    a1f7:	67 66 8b 5d fc       	mov    -0x4(%di),%bx
    a1fc:	66 c9                	leavew 
    a1fe:	66 c3                	retw   

0000a200 <_Z7getcharv>:
#endif


#ifndef _HHOS_LIBC_TEST
int getchar(void)
{
    a200:	66 55                	push   %bp
    a202:	66 89 e5             	mov    %sp,%bp
    );
    a205:	b4 00                	mov    $0x0,%ah
    a207:	cd 98                	int    $0x98
    a209:	66 89 c2             	mov    %ax,%dx
    ret = ret & mask;
    a20c:	66 0f b6 c2          	movzbw %dl,%ax
    return system_call_getchar();
}
    a210:	66 5d                	pop    %bp
    a212:	66 c3                	retw   

0000a214 <_Z4getsPc>:
char *gets( char *str )
{
    a214:	66 55                	push   %bp
    a216:	66 89 e5             	mov    %sp,%bp
    a219:	66 53                	push   %bx
    a21b:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    );
    a220:	b4 00                	mov    $0x0,%ah
    a222:	cd 98                	int    $0x98
    a224:	66 89 c3             	mov    %ax,%bx
    char ch;
    while(true)
    {
        ch = getchar();
        putchar(ch);
    a227:	66 0f be c3          	movsbw %bl,%ax
    system_call_putchar(ch);
    a22b:	66 e8 4c ff          	callw  a17b <_Z7isdigiti+0x1b>
    a22f:	ff                   	(bad)  
    a230:	ff 80 fb 0d 74 08    	incl   0x8740dfb(%eax)
        if(ch == 13) {
            putchar('\n');
            break;
        }
        *(str++) = ch;
    a236:	66 41                	inc    %cx
    a238:	67 88 59 ff          	mov    %bl,-0x1(%bx,%di)
        ch = getchar();
    a23c:	eb e2                	jmp    a220 <_Z4getsPc+0xc>
    system_call_putchar(ch);
    a23e:	66 b8 0a 00          	mov    $0xa,%ax
    a242:	00 00                	add    %al,(%eax)
    a244:	66 e8 33 ff          	callw  a17b <_Z7isdigiti+0x1b>
    a248:	ff                   	(bad)  
    a249:	ff 67 c6             	jmp    *-0x3a(%edi)
    }
    *str = '\0';
    a24c:	01 00                	add    %eax,(%eax)
    return str;
}
    a24e:	66 89 c8             	mov    %cx,%ax
    a251:	66 5b                	pop    %bx
    a253:	66 5d                	pop    %bp
    a255:	66 c3                	retw   

0000a257 <_Z7vsscanfPKcS0_Pc>:
#endif

int vsscanf( const char* buffer, const char* format, va_list vlist )
{
    a257:	66 55                	push   %bp
    a259:	66 89 e5             	mov    %sp,%bp
    a25c:	66 57                	push   %di
    a25e:	66 56                	push   %si
    a260:	66 53                	push   %bx
    a262:	66 83 ec 14          	sub    $0x14,%sp
    a266:	67 66 8b 75 08       	mov    0x8(%di),%si
    a26b:	67 66 8b 7d 10       	mov    0x10(%di),%di
    auto len_fmt = strlen(format);
    a270:	67 66 ff 75 0c       	pushw  0xc(%di)
    a275:	66 e8 dc 04          	callw  a755 <_Z6memsetPvim+0x23>
    a279:	00 00                	add    %al,(%eax)
    a27b:	67 66 89 45 e0       	mov    %ax,-0x20(%di)
    a280:	66 59                	pop    %cx
    auto p_fmt = format; 
    a282:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    a287:	67 66 89 45 e8       	mov    %ax,-0x18(%di)
    auto p_buf = buffer;
    bool error = false;
    int ret = 0;
    a28c:	67 66 c7 45 ec 00 00 	movw   $0x0,-0x14(%di)
    a293:	00 00                	add    %al,(%eax)
    bool error = false;
    a295:	67 c6 45 e7 00       	movb   $0x0,-0x19(%di)
    while(static_cast<size_t>(p_fmt - format) < len_fmt)
    a29a:	67 66 8b 45 e8       	mov    -0x18(%di),%ax
    a29f:	67 66 2b 45 0c       	sub    0xc(%di),%ax
    a2a4:	67 66 3b 45 e0       	cmp    -0x20(%di),%ax
    a2a9:	0f 93 c0             	setae  %al
    {
        if(error) break;
    a2ac:	67 08 45 e7          	or     %al,-0x19(%di)
    a2b0:	0f 85 50 01 67 66    	jne    6667a406 <_GLOBAL_OFFSET_TABLE_+0x6666e2e6>
        if(isspace(*p_fmt)) //略过白空格
    a2b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a2b9:	67 66 0f be 00       	movsbw (%bx,%si),%ax
    a2be:	66 50                	push   %ax
    a2c0:	66 e8 44 fe          	callw  a108 <_start+0x8>
    a2c4:	ff                   	(bad)  
    a2c5:	ff 66 5a             	jmp    *0x5a(%esi)
    a2c8:	66 85 c0             	test   %ax,%ax
    a2cb:	74 1d                	je     a2ea <_Z7vsscanfPKcS0_Pc+0x93>
        {
            p_fmt++;
    a2cd:	67 66 ff 45 e8       	incw   -0x18(%di)
            while(isspace(*buffer)) buffer++;
    a2d2:	67 66 0f be 06 66 50 	movsbw 0x5066,%ax
    a2d9:	66 e8 2b fe          	callw  a108 <_start+0x8>
    a2dd:	ff                   	(bad)  
    a2de:	ff 66 5b             	jmp    *0x5b(%esi)
    a2e1:	66 85 c0             	test   %ax,%ax
    a2e4:	74 b4                	je     a29a <_Z7vsscanfPKcS0_Pc+0x43>
    a2e6:	66 46                	inc    %si
    a2e8:	eb e8                	jmp    a2d2 <_Z7vsscanfPKcS0_Pc+0x7b>
            continue;
        }
        else if(*p_fmt == '%') //格式控制符
    a2ea:	67 66 8b 45 e8       	mov    -0x18(%di),%ax
    a2ef:	67 80 38 25          	cmpb   $0x25,(%bx,%si)
    a2f3:	75 a5                	jne    a29a <_Z7vsscanfPKcS0_Pc+0x43>
        {
            p_fmt++;
            char specifier = *p_fmt;
    a2f5:	67 8a 40 01          	mov    0x1(%bx,%si),%al
            p_fmt++;
    a2f9:	67 66 83 45 e8 02    	addw   $0x2,-0x18(%di)
            switch(specifier)
    a2ff:	3c 69                	cmp    $0x69,%al
    a301:	0f 84 b0 00 7f 25    	je     257fa3b7 <_GLOBAL_OFFSET_TABLE_+0x257ee297>
    a307:	3c 58                	cmp    $0x58,%al
    a309:	0f 84 c4 00 7f 10    	je     107fa3d3 <_GLOBAL_OFFSET_TABLE_+0x107ee2b3>
    a30f:	3c 25                	cmp    $0x25,%al
    a311:	75 87                	jne    a29a <_Z7vsscanfPKcS0_Pc+0x43>
            {
                case '%':
                {
                    if(*buffer == '%') 
    a313:	67 80 3e 25 67 0f    	cmpb   $0xf,0x6725
    a319:	95                   	xchg   %eax,%ebp
    a31a:	45                   	inc    %ebp
    a31b:	e7 e9                	out    %eax,$0xe9
    a31d:	7b ff                	jnp    a31e <_Z7vsscanfPKcS0_Pc+0xc7>
            switch(specifier)
    a31f:	3c 63                	cmp    $0x63,%al
    a321:	74 31                	je     a354 <_Z7vsscanfPKcS0_Pc+0xfd>
    a323:	3c 64                	cmp    $0x64,%al
    a325:	0f 84 9a 00 e9 6e    	je     6ee9a3c5 <_GLOBAL_OFFSET_TABLE_+0x6ee8e2a5>
    a32b:	ff                   	(bad)  
    a32c:	3c 73                	cmp    $0x73,%al
    a32e:	74 4d                	je     a37d <_Z7vsscanfPKcS0_Pc+0x126>
    a330:	7f 15                	jg     a347 <_Z7vsscanfPKcS0_Pc+0xf0>
    a332:	3c 6f                	cmp    $0x6f,%al
    a334:	0f 85 62 ff 67 66    	jne    6668a29c <_GLOBAL_OFFSET_TABLE_+0x6667e17c>
                    ++ret;
                    break;
                }
                case 'o':
                {
                    unsigned int* p = va_arg(vlist, unsigned int*);
    a33a:	8d 5f 04             	lea    0x4(%edi),%ebx
    a33d:	67 66 8b 3f          	mov    (%bx),%di
                    char* end;
                    long num = strtol(buffer, &end, 8);
    a341:	66 6a 08             	pushw  $0x8
    a344:	e9 96 00 3c 75       	jmp    753ca3df <_GLOBAL_OFFSET_TABLE_+0x753be2bf>
            switch(specifier)
    a349:	74 78                	je     a3c3 <_Z7vsscanfPKcS0_Pc+0x16c>
    a34b:	3c 78                	cmp    $0x78,%al
    a34d:	0f 84 80 00 e9 46    	je     46e9a3d3 <_GLOBAL_OFFSET_TABLE_+0x46e8e2b3>
    a353:	ff 67 66             	jmp    *0x66(%edi)
                    char* p = va_arg(vlist, char*);
    a356:	8b 17                	mov    (%edi),%edx
                    *p = *buffer;
    a358:	67 8a 06 67 88       	mov    -0x7799,%al
    a35d:	02 66 46             	add    0x46(%esi),%ah
                    ++ret;
    a360:	67 66 ff 45 ec       	incw   -0x14(%di)
                    char* p = va_arg(vlist, char*);
    a365:	66 83 c7 04          	add    $0x4,%di
                    break;
    a369:	e9 2e ff 66 50       	jmp    5067a29c <_GLOBAL_OFFSET_TABLE_+0x5066e17c>
                    while (*buffer && isspace(*buffer)) buffer++;
    a36e:	66 e8 96 fd          	callw  a108 <_start+0x8>
    a372:	ff                   	(bad)  
    a373:	ff 66 59             	jmp    *0x59(%esi)
    a376:	66 85 c0             	test   %ax,%ax
    a379:	74 0b                	je     a386 <_Z7vsscanfPKcS0_Pc+0x12f>
    a37b:	66 46                	inc    %si
    a37d:	67 66 0f be 06 84 c0 	movsbw -0x3f7c,%ax
    a384:	75 e6                	jne    a36c <_Z7vsscanfPKcS0_Pc+0x115>
                    char* p = va_arg(vlist, char*);
    a386:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    a38b:	67 66 8b 3f          	mov    (%bx),%di
                    while(*buffer && !isspace(*buffer))
    a38f:	67 66 0f be 06 84 c0 	movsbw -0x3f7c,%ax
    a396:	75 0b                	jne    a3a3 <_Z7vsscanfPKcS0_Pc+0x14c>
                    *p = '\0';
    a398:	67 c6 07 00          	movb   $0x0,(%bx)
                    ++ret;
    a39c:	67 66 ff 45 ec       	incw   -0x14(%di)
    a3a1:	eb 5b                	jmp    a3fe <_Z7vsscanfPKcS0_Pc+0x1a7>
                    while(*buffer && !isspace(*buffer))
    a3a3:	66 50                	push   %ax
    a3a5:	66 e8 5f fd          	callw  a108 <_start+0x8>
    a3a9:	ff                   	(bad)  
    a3aa:	ff 66 5a             	jmp    *0x5a(%esi)
    a3ad:	66 85 c0             	test   %ax,%ax
    a3b0:	75 e6                	jne    a398 <_Z7vsscanfPKcS0_Pc+0x141>
                        *(p++) = *(buffer++);
    a3b2:	a4                   	movsb  %ds:(%esi),%es:(%edi)
                    while(*buffer && !isspace(*buffer))
    a3b3:	eb da                	jmp    a38f <_Z7vsscanfPKcS0_Pc+0x138>
                    int* p = va_arg(vlist, int*);
    a3b5:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    a3ba:	67 66 8b 3f          	mov    (%bx),%di
                    long num = strtol(buffer, &end, 0);
    a3be:	66 6a 00             	pushw  $0x0
    a3c1:	eb 1a                	jmp    a3dd <_Z7vsscanfPKcS0_Pc+0x186>
                    unsigned int* p = va_arg(vlist, unsigned int*);
    a3c3:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    a3c8:	67 66 8b 3f          	mov    (%bx),%di
                    long num = strtol(buffer, &end, 10);
    a3cc:	66 6a 0a             	pushw  $0xa
    a3cf:	eb 0c                	jmp    a3dd <_Z7vsscanfPKcS0_Pc+0x186>
                    break;
                }
                case 'x':
                case 'X':
                {
                    unsigned int* p = va_arg(vlist, unsigned int*);
    a3d1:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    a3d6:	67 66 8b 3f          	mov    (%bx),%di
                    char* end;
                    long num = strtol(buffer, &end, 16);
    a3da:	66 6a 10             	pushw  $0x10
    a3dd:	67 66 8d 45 f0       	lea    -0x10(%di),%ax
    a3e2:	66 50                	push   %ax
    a3e4:	66 56                	push   %si
    a3e6:	66 e8 cc 04          	callw  a8b6 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x48>
    a3ea:	00 00                	add    %al,(%eax)
                    *p = static_cast<unsigned int>(num);
    a3ec:	67 66 89 07          	mov    %ax,(%bx)
                    buffer = end;
    a3f0:	67 66 8b 75 f0       	mov    -0x10(%di),%si
                    ++ret;
    a3f5:	67 66 ff 45 ec       	incw   -0x14(%di)
    a3fa:	66 83 c4 0c          	add    $0xc,%sp
                    unsigned int* p = va_arg(vlist, unsigned int*);
    a3fe:	66 89 df             	mov    %bx,%di
    a401:	e9 96 fe 67 66       	jmp    6668a29c <_GLOBAL_OFFSET_TABLE_+0x6667e17c>
                    break;
            }
        }
    }
    return ret;
}
    a406:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a409:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    a40e:	66 5b                	pop    %bx
    a410:	66 5e                	pop    %si
    a412:	66 5f                	pop    %di
    a414:	66 5d                	pop    %bp
    a416:	66 c3                	retw   

0000a418 <_Z6sscanfPKcS0_z>:
int sscanf( const char* buffer, const char* format, ... )
{
    a418:	66 55                	push   %bp
    a41a:	66 89 e5             	mov    %sp,%bp
   	int ret;
	va_list va;
	va_start(va, format);
    a41d:	67 66 8d 45 10       	lea    0x10(%di),%ax
	ret = vsscanf(buffer, format, va);
    a422:	66 50                	push   %ax
    a424:	67 66 ff 75 0c       	pushw  0xc(%di)
    a429:	67 66 ff 75 08       	pushw  0x8(%di)
    a42e:	66 e8 23 fe          	callw  a255 <_Z4getsPc+0x41>
    a432:	ff                   	(bad)  
    a433:	ff 66 c9             	jmp    *-0x37(%esi)
	va_end(va);
    return ret; 
}
    a436:	66 c3                	retw   

0000a438 <_Z5scanfPKcz>:
#ifndef _HHOS_LIBC_TEST
static char scanfbuf[80*25];
//TODO 关于这个返回值
int scanf( const char* format, ... )
{
    a438:	66 55                	push   %bp
    a43a:	66 89 e5             	mov    %sp,%bp
    if (!gets(scanfbuf)) return EOF;
    a43d:	66 68 20 b1          	pushw  $0xb120
    a441:	00 00                	add    %al,(%eax)
    a443:	66 e8 cb fd          	callw  a212 <_Z7getcharv+0x12>
    a447:	ff                   	(bad)  
    a448:	ff 66 89             	jmp    *-0x77(%esi)
    a44b:	c2 66 58             	ret    $0x5866
    a44e:	66 83 c8 ff          	or     $0xffff,%ax
    a452:	66 85 d2             	test   %dx,%dx
    a455:	74 1c                	je     a473 <_Z5scanfPKcz+0x3b>
	int ret;
	va_list va;
	va_start(va, format);
    a457:	67 66 8d 45 0c       	lea    0xc(%di),%ax
	ret = vsscanf(scanfbuf, format, va);
    a45c:	66 50                	push   %ax
    a45e:	67 66 ff 75 08       	pushw  0x8(%di)
    a463:	66 68 20 b1          	pushw  $0xb120
    a467:	00 00                	add    %al,(%eax)
    a469:	66 e8 e8 fd          	callw  a255 <_Z4getsPc+0x41>
    a46d:	ff                   	(bad)  
    a46e:	ff 66 83             	jmp    *-0x7d(%esi)
	va_end(va);
    return ret;
    a471:	c4 0c 66             	les    (%esi,%eiz,2),%ecx
}
    a474:	c9                   	leave  
    a475:	66 c3                	retw   

0000a477 <_Z8vsprintfPcPKcS_>:
{
    a477:	66 55                	push   %bp
    a479:	66 89 e5             	mov    %sp,%bp
    a47c:	66 57                	push   %di
    a47e:	66 56                	push   %si
    a480:	66 53                	push   %bx
    a482:	66 83 ec 0c          	sub    $0xc,%sp
    a486:	67 66 8b 75 0c       	mov    0xc(%di),%si
    a48b:	67 66 8b 55 10       	mov    0x10(%di),%dx
    a490:	67 66 89 55 f0       	mov    %dx,-0x10(%di)
    auto len_fmt = strlen(format);
    a495:	66 56                	push   %si
    a497:	66 e8 ba 02          	callw  a755 <_Z6memsetPvim+0x23>
    a49b:	00 00                	add    %al,(%eax)
    a49d:	67 66 89 45 ec       	mov    %ax,-0x14(%di)
    a4a2:	66 58                	pop    %ax
    auto p_buf = buffer;
    a4a4:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    a4a9:	67 66 8b 55 f0       	mov    -0x10(%di),%dx
    while(len_fmt--)
    a4ae:	67 66 ff 4d ec       	decw   -0x14(%di)
    a4b3:	67 66 83 7d ec ff    	cmpw   $0xffff,-0x14(%di)
    a4b9:	0f 84 4a 01 67 8a    	je     8a67a609 <_GLOBAL_OFFSET_TABLE_+0x8a66e4e9>
        if(*p_fmt != '%')
    a4bf:	06                   	push   %es
    a4c0:	3c 25                	cmp    $0x25,%al
    a4c2:	74 07                	je     a4cb <_Z8vsprintfPcPKcS_+0x54>
            *(p_buf++) = *(p_fmt++);    //非控制字符
    a4c4:	66 46                	inc    %si
    a4c6:	67 88 03             	mov    %al,(%bp,%di)
    a4c9:	eb 5f                	jmp    a52a <_Z8vsprintfPcPKcS_+0xb3>
            char specifier = *(++p_fmt); //%后面一个字符是specifier
    a4cb:	67 8a 46 01          	mov    0x1(%bp),%al
            ++p_fmt;                     //记录specifier并跳过
    a4cf:	66 83 c6 02          	add    $0x2,%si
            switch (specifier)
    a4d3:	3c 69                	cmp    $0x69,%al
    a4d5:	0f 84 81 00 7f 17    	je     177fa55c <_GLOBAL_OFFSET_TABLE_+0x177ee43c>
    a4db:	3c 63                	cmp    $0x63,%al
    a4dd:	74 40                	je     a51f <_Z8vsprintfPcPKcS_+0xa8>
    a4df:	3c 64                	cmp    $0x64,%al
    a4e1:	74 77                	je     a55a <_Z8vsprintfPcPKcS_+0xe3>
    a4e3:	3c 58                	cmp    $0x58,%al
    a4e5:	75 c7                	jne    a4ae <_Z8vsprintfPcPKcS_+0x37>
                    unsigned int num = va_arg(vlist, int);
    a4e7:	67 66 8d 7a 04       	lea    0x4(%bp,%si),%di
                    itoa(p_buf, num, 16, true);
    a4ec:	66 6a 01             	pushw  $0x1
    a4ef:	e9 e2 00 3c 73       	jmp    733ca5d6 <_GLOBAL_OFFSET_TABLE_+0x733be4b6>
            switch (specifier)
    a4f4:	74 38                	je     a52e <_Z8vsprintfPcPKcS_+0xb7>
    a4f6:	7f 12                	jg     a50a <_Z8vsprintfPcPKcS_+0x93>
    a4f8:	3c 6f                	cmp    $0x6f,%al
    a4fa:	75 b2                	jne    a4ae <_Z8vsprintfPcPKcS_+0x37>
                    unsigned int num = va_arg(vlist, int);
    a4fc:	67 66 8d 7a 04       	lea    0x4(%bp,%si),%di
                    itoa(p_buf, num, 8);
    a501:	66 6a 00             	pushw  $0x0
    a504:	66 6a 08             	pushw  $0x8
    a507:	e9 da 00 3c 75       	jmp    753ca5e6 <_GLOBAL_OFFSET_TABLE_+0x753be4c6>
            switch (specifier)
    a50c:	0f 84 c9 00 3c 78    	je     783ca5db <_GLOBAL_OFFSET_TABLE_+0x783be4bb>
    a512:	75 9a                	jne    a4ae <_Z8vsprintfPcPKcS_+0x37>
                    unsigned int num = va_arg(vlist, int);
    a514:	67 66 8d 7a 04       	lea    0x4(%bp,%si),%di
                    itoa(p_buf, num, 16);
    a519:	66 6a 00             	pushw  $0x0
    a51c:	e9 b5 00 67 66       	jmp    6667a5d6 <_GLOBAL_OFFSET_TABLE_+0x6666e4b6>
                    *(p_buf++) = va_arg(vlist, int); 
    a521:	8b 02                	mov    (%edx),%eax
    a523:	67 88 03             	mov    %al,(%bp,%di)
    a526:	66 83 c2 04          	add    $0x4,%dx
    a52a:	66 43                	inc    %bx
                    break;
    a52c:	eb 80                	jmp    a4ae <_Z8vsprintfPcPKcS_+0x37>
                    const char * str = va_arg(vlist, char*);
    a52e:	67 66 8d 42 04       	lea    0x4(%bp,%si),%ax
    a533:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
    a538:	67 66 8b 3a          	mov    (%bp,%si),%di
                    strcpy(p_buf, str);
    a53c:	66 57                	push   %di
    a53e:	66 53                	push   %bx
    a540:	66 e8 2d 02          	callw  a771 <_Z6strlenPKc+0x1a>
    a544:	00 00                	add    %al,(%eax)
                    p_buf += strlen(str);               //p应当永远指向有意义的字符后面一位
    a546:	66 59                	pop    %cx
    a548:	66 58                	pop    %ax
    a54a:	66 57                	push   %di
    a54c:	66 e8 05 02          	callw  a755 <_Z6memsetPvim+0x23>
    a550:	00 00                	add    %al,(%eax)
    a552:	66 01 c3             	add    %ax,%bx
                    break;
    a555:	66 58                	pop    %ax
    a557:	e9 4f ff 67 66       	jmp    6668a4ab <_GLOBAL_OFFSET_TABLE_+0x6667e38b>
                    int num = va_arg(vlist, int);
    a55c:	8d 42 04             	lea    0x4(%edx),%eax
    a55f:	67 66 89 45 e8       	mov    %ax,-0x18(%di)
    a564:	67 66 8b 02          	mov    (%bp,%si),%ax
template<typename T>
void itoa(char* buffer, T num, int base, bool captial = false)
{
    const char* num_char_upper = "0123456789ABCDEF";
    const char* num_char_lower = "0123456789abcdef";
    if(num < 0)
    a568:	66 89 df             	mov    %bx,%di
    a56b:	66 85 c0             	test   %ax,%ax
    a56e:	79 0c                	jns    a57c <_Z8vsprintfPcPKcS_+0x105>
    a570:	67 66 8d 7b 01       	lea    0x1(%bp,%di),%di
    {
        *(buffer++) = '-';
    a575:	67 c6 03 2d          	movb   $0x2d,(%bp,%di)
        num = -num;
    a579:	66 f7 d8             	neg    %ax
    }
    char *p = buffer;
    a57c:	67 66 89 7d f0       	mov    %di,-0x10(%di)
    int mod = 0;
    while(true)
    {
        mod = num % base;
        num /= base;
    a581:	66 b9 0a 00          	mov    $0xa,%cx
    a585:	00 00                	add    %al,(%eax)
    a587:	66 99                	cwtd   
    a589:	66 f7 f9             	idiv   %cx
        *(p++) = captial ? num_char_upper[mod] : num_char_lower[mod];
    a58c:	67 66 8b 4d f0       	mov    -0x10(%di),%cx
    a591:	66 41                	inc    %cx
    a593:	67 8a 92 0e c1       	mov    -0x3ef2(%bp,%si),%dl
    a598:	00 00                	add    %al,(%eax)
    a59a:	67 88 51 ff          	mov    %dl,-0x1(%bx,%di)
        if(num == 0) break;
    a59e:	66 85 c0             	test   %ax,%ax
    a5a1:	74 07                	je     a5aa <_Z8vsprintfPcPKcS_+0x133>
    a5a3:	67 66 89 4d f0       	mov    %cx,-0x10(%di)
    a5a8:	eb d7                	jmp    a581 <_Z8vsprintfPcPKcS_+0x10a>
    }
    *p = '\0';
    a5aa:	67 66 8b 45 f0       	mov    -0x10(%di),%ax
    a5af:	67 c6 40 01 00       	movb   $0x0,0x1(%bx,%si)
    reverse(buffer);
    a5b4:	66 57                	push   %di
    a5b6:	66 e8 66 02          	callw  a820 <_Z6strcmpPKcS0_+0x6b>
    a5ba:	00 00                	add    %al,(%eax)
                    p_buf += strlen(p_buf);             //同理
    a5bc:	67 66 89 1c          	mov    %bx,(%si)
    a5c0:	24 66                	and    $0x66,%al
    a5c2:	e8 90 01 00 00       	call   a757 <_Z6strlenPKc>
    a5c7:	66 01 c3             	add    %ax,%bx
                    break;
    a5ca:	66 5a                	pop    %dx
                    int num = va_arg(vlist, int);
    a5cc:	67 66 8b 55 e8       	mov    -0x18(%di),%dx
                    break;
    a5d1:	e9 da fe 66 6a       	jmp    6a67a4b0 <_GLOBAL_OFFSET_TABLE_+0x6a66e390>
                    itoa(p_buf, num, 16, true);
    a5d6:	10 eb                	adc    %ch,%bl
    a5d8:	0b 67 66             	or     0x66(%edi),%esp
                    unsigned int num = va_arg(vlist, int);
    a5db:	8d 7a 04             	lea    0x4(%edx),%edi
                    itoa(p_buf, num, 10);
    a5de:	66 6a 00             	pushw  $0x0
    a5e1:	66 6a 0a             	pushw  $0xa
    a5e4:	67 66 ff 32          	pushw  (%bp,%si)
    a5e8:	66 53                	push   %bx
    a5ea:	66 e8 be 06          	callw  acac <_text_end+0x24b>
    a5ee:	00 00                	add    %al,(%eax)
                    p_buf += strlen(p_buf);             //同理
    a5f0:	66 83 c4 10          	add    $0x10,%sp
    a5f4:	66 53                	push   %bx
    a5f6:	66 e8 5b 01          	callw  a755 <_Z6memsetPvim+0x23>
    a5fa:	00 00                	add    %al,(%eax)
    a5fc:	66 01 c3             	add    %ax,%bx
                    break;
    a5ff:	66 58                	pop    %ax
                    unsigned int num = va_arg(vlist, int);
    a601:	66 89 fa             	mov    %di,%dx
                    break;
    a604:	e9 a7 fe 67 c6       	jmp    c668a4b0 <_GLOBAL_OFFSET_TABLE_+0xc667e390>
    *p_buf = '\0';
    a609:	03 00                	add    (%eax),%eax
    return p_buf - buffer;
    a60b:	66 89 d8             	mov    %bx,%ax
    a60e:	67 66 2b 45 08       	sub    0x8(%di),%ax
}
    a613:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    a618:	66 5b                	pop    %bx
    a61a:	66 5e                	pop    %si
    a61c:	66 5f                	pop    %di
    a61e:	66 5d                	pop    %bp
    a620:	66 c3                	retw   

0000a622 <_Z7sprintfPcPKcz>:
{
    a622:	66 55                	push   %bp
    a624:	66 89 e5             	mov    %sp,%bp
	va_start(va, format);
    a627:	67 66 8d 45 10       	lea    0x10(%di),%ax
	ret = vsprintf(buffer, format, va);
    a62c:	66 50                	push   %ax
    a62e:	67 66 ff 75 0c       	pushw  0xc(%di)
    a633:	67 66 ff 75 08       	pushw  0x8(%di)
    a638:	66 e8 39 fe          	callw  a475 <_Z5scanfPKcz+0x3d>
    a63c:	ff                   	(bad)  
    a63d:	ff 66 c9             	jmp    *-0x37(%esi)
}
    a640:	66 c3                	retw   

0000a642 <_Z6printfPKcz>:
{
    a642:	66 55                	push   %bp
    a644:	66 89 e5             	mov    %sp,%bp
    a647:	66 53                	push   %bx
	va_start(va, format);
    a649:	67 66 8d 45 0c       	lea    0xc(%di),%ax
	ret = vsprintf(printbuf, format, va);
    a64e:	66 50                	push   %ax
    a650:	67 66 ff 75 08       	pushw  0x8(%di)
    a655:	66 68 00 b9          	pushw  $0xb900
    a659:	00 00                	add    %al,(%eax)
    a65b:	66 e8 16 fe          	callw  a475 <_Z5scanfPKcz+0x3d>
    a65f:	ff                   	(bad)  
    a660:	ff 66 89             	jmp    *-0x77(%esi)
    a663:	c3                   	ret    
    puts(printbuf);
    a664:	66 83 c4 0c          	add    $0xc,%sp
    a668:	66 68 00 b9          	pushw  $0xb900
    a66c:	00 00                	add    %al,(%eax)
    a66e:	66 e8 4e fb          	callw  a1c0 <_Z7putchari+0x18>
    a672:	ff                   	(bad)  
    a673:	ff 66 89             	jmp    *-0x77(%esi)
}
    a676:	d8 67 66             	fsubs  0x66(%edi)
    a679:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a67c:	66 c9                	leavew 
    a67e:	66 c3                	retw   

0000a680 <_Z6memcmpPKvS0_m>:
namespace hhlibc {

#endif

int memcmp(const void * _s1, const void* _s2, size_t n)
{
    a680:	66 55                	push   %bp
    a682:	66 89 e5             	mov    %sp,%bp
    a685:	66 31 d2             	xor    %dx,%dx
    auto s1 = reinterpret_cast<const unsigned char*>(_s1);
    auto s2 = reinterpret_cast<const unsigned char*>(_s2);
    while(n--)
    a688:	67 66 39 55 10       	cmp    %dx,0x10(%di)
    a68d:	74 22                	je     a6b1 <_Z6memcmpPKvS0_m+0x31>
    {
        if(*s1 != *s2)          //**不能**让!=时跳出然后返回*s1 - *s2
    a68f:	67 66 8b 45 08       	mov    0x8(%di),%ax
    a694:	67 66 0f b6 04       	movzbw (%si),%ax
    a699:	10 66 42             	adc    %ah,0x42(%esi)
    a69c:	67 66 8b 4d 0c       	mov    0xc(%di),%cx
    a6a1:	67 66 0f b6 4c 11    	movzbw 0x11(%si),%cx
    a6a7:	ff                   	(bad)  
    a6a8:	38 c8                	cmp    %cl,%al
    a6aa:	74 dc                	je     a688 <_Z6memcmpPKvS0_m+0x8>
        {                       //因为那样在实际上==的时候，会比较错误
            return *s1 - *s2;
    a6ac:	66 29 c8             	sub    %cx,%ax
    a6af:	eb 03                	jmp    a6b4 <_Z6memcmpPKvS0_m+0x34>
        }
        ++s1;
        ++s2;
    }
    return 0;
    a6b1:	66 31 c0             	xor    %ax,%ax
}
    a6b4:	66 5d                	pop    %bp
    a6b6:	66 c3                	retw   

0000a6b8 <_Z6memcpyPvPKvm>:

void* memcpy(void* _dst, const void* _src, size_t n)
{
    a6b8:	66 55                	push   %bp
    a6ba:	66 89 e5             	mov    %sp,%bp
    a6bd:	66 53                	push   %bx
    a6bf:	67 66 8b 45 08       	mov    0x8(%di),%ax
    a6c4:	67 66 8b 5d 0c       	mov    0xc(%di),%bx
    a6c9:	66 31 d2             	xor    %dx,%dx
    auto dst = reinterpret_cast<unsigned char*>(_dst);
    auto src = reinterpret_cast<const unsigned char*>(_src);
    while (n--)
    a6cc:	67 66 39 55 10       	cmp    %dx,0x10(%di)
    a6d1:	74 0c                	je     a6df <_Z6memcpyPvPKvm+0x27>
    {
        *(dst++) = *(src++);
    a6d3:	67 8a 0c             	mov    (%si),%cl
    a6d6:	13 67 88             	adc    -0x78(%edi),%esp
    a6d9:	0c 10                	or     $0x10,%al
    a6db:	66 42                	inc    %dx
    while (n--)
    a6dd:	eb ed                	jmp    a6cc <_Z6memcpyPvPKvm+0x14>
    }
    return _dst;
}
    a6df:	66 5b                	pop    %bx
    a6e1:	66 5d                	pop    %bp
    a6e3:	66 c3                	retw   

0000a6e5 <_Z7memmovePvPKvm>:
void* memmove(void* _dst, const void* _src, size_t n)
{
    a6e5:	66 55                	push   %bp
    a6e7:	66 89 e5             	mov    %sp,%bp
    a6ea:	66 56                	push   %si
    a6ec:	66 53                	push   %bx
    a6ee:	67 66 8b 45 08       	mov    0x8(%di),%ax
    a6f3:	67 66 8b 5d 0c       	mov    0xc(%di),%bx
    a6f8:	67 66 8b 75 10       	mov    0x10(%di),%si
    auto dst = reinterpret_cast<unsigned char*>(_dst);
    auto src = reinterpret_cast<const unsigned char*>(_src);
    if(dst < src)
    a6fd:	66 39 d8             	cmp    %bx,%ax
    a700:	73 14                	jae    a716 <_Z7memmovePvPKvm+0x31>
    a702:	66 31 c9             	xor    %cx,%cx
    {
        while(n--)
    a705:	66 39 f1             	cmp    %si,%cx
    a708:	74 20                	je     a72a <_Z7memmovePvPKvm+0x45>
        {
            *(dst++) = *(src++);
    a70a:	67 8a 14             	mov    (%si),%dl
    a70d:	0b 67 88             	or     -0x78(%edi),%esp
    a710:	14 08                	adc    $0x8,%al
    a712:	66 41                	inc    %cx
        while(n--)
    a714:	eb ef                	jmp    a705 <_Z7memmovePvPKvm+0x20>
        }
    }
    else if(dst > src)
    a716:	76 12                	jbe    a72a <_Z7memmovePvPKvm+0x45>
    {
        src += n;
        dst += n;
        while(n--)
    a718:	66 4e                	dec    %si
    a71a:	66 83 fe ff          	cmp    $0xffff,%si
    a71e:	74 0a                	je     a72a <_Z7memmovePvPKvm+0x45>
        {
            *(--dst) = *(--src);
    a720:	67 8a 0c             	mov    (%si),%cl
    a723:	33 67 88             	xor    -0x78(%edi),%esp
    a726:	0c 30                	or     $0x30,%al
        while(n--)
    a728:	eb ee                	jmp    a718 <_Z7memmovePvPKvm+0x33>
        }
    }
    return _dst;
}
    a72a:	66 5b                	pop    %bx
    a72c:	66 5e                	pop    %si
    a72e:	66 5d                	pop    %bp
    a730:	66 c3                	retw   

0000a732 <_Z6memsetPvim>:
void* memset(void* _dst, int c, size_t n)
{
    a732:	66 55                	push   %bp
    a734:	66 89 e5             	mov    %sp,%bp
    a737:	67 66 8b 45 08       	mov    0x8(%di),%ax
    a73c:	67 66 8b 4d 0c       	mov    0xc(%di),%cx
    a741:	66 31 d2             	xor    %dx,%dx
    auto dst = reinterpret_cast<unsigned char*>(_dst);
    while(n--)
    a744:	67 66 39 55 10       	cmp    %dx,0x10(%di)
    a749:	74 08                	je     a753 <_Z6memsetPvim+0x21>
    {
        *(dst++) = static_cast<unsigned char>(c);
    a74b:	67 88 0c             	mov    %cl,(%si)
    a74e:	10 66 42             	adc    %ah,0x42(%esi)
    while(n--)
    a751:	eb f1                	jmp    a744 <_Z6memsetPvim+0x12>
    }
    return _dst;
}
    a753:	66 5d                	pop    %bp
    a755:	66 c3                	retw   

0000a757 <_Z6strlenPKc>:
size_t strlen(const char* _str)
{
    a757:	66 55                	push   %bp
    a759:	66 89 e5             	mov    %sp,%bp
    a75c:	67 66 8b 55 08       	mov    0x8(%di),%dx
    auto str = _str;
    size_t len = 0;
    a761:	66 31 c0             	xor    %ax,%ax
    while(*(_str++))
    a764:	67 80 3c 02          	cmpb   $0x2,(%si)
    a768:	00 74 04 66          	add    %dh,0x66(%esp,%eax,1)
    {
        len++;
    a76c:	40                   	inc    %eax
    while(*(_str++))
    a76d:	eb f5                	jmp    a764 <_Z6strlenPKc+0xd>
    }
    return len;
}
    a76f:	66 5d                	pop    %bp
    a771:	66 c3                	retw   

0000a773 <_Z6strcpyPcPKc>:
char *strcpy(char* _dst, const char* _src)
{
    a773:	66 55                	push   %bp
    a775:	66 89 e5             	mov    %sp,%bp
    a778:	66 56                	push   %si
    a77a:	66 53                	push   %bx
    a77c:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    a781:	67 66 8b 4d 0c       	mov    0xc(%di),%cx
    auto len = strlen(_src);
    a786:	66 51                	push   %cx
    a788:	66 e8 c9 ff          	callw  a755 <_Z6memsetPvim+0x23>
    a78c:	ff                   	(bad)  
    a78d:	ff 66 89             	jmp    *-0x77(%esi)
    a790:	c6                   	(bad)  
    memcpy(reinterpret_cast<void*>(_dst), reinterpret_cast<const void *>(_src), len);
    a791:	67 66 89 04          	mov    %ax,(%si)
    a795:	24 66                	and    $0x66,%al
    a797:	51                   	push   %ecx
    a798:	66 53                	push   %bx
    a79a:	66 e8 18 ff          	callw  a6b6 <_Z6memcmpPKvS0_m+0x36>
    a79e:	ff                   	(bad)  
    a79f:	ff 67 c6             	jmp    *-0x3a(%edi)
    _dst[len] = '\0';
    a7a2:	04 33                	add    $0x33,%al
    a7a4:	00 66 89             	add    %ah,-0x77(%esi)
    return _dst;
}
    a7a7:	d8 67 66             	fsubs  0x66(%edi)
    a7aa:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a7ad:	66 5b                	pop    %bx
    a7af:	66 5e                	pop    %si
    a7b1:	66 5d                	pop    %bp
    a7b3:	66 c3                	retw   

0000a7b5 <_Z6strcmpPKcS0_>:
int strcmp(const char* _s1, const char* _s2)
{
    a7b5:	66 55                	push   %bp
    a7b7:	66 89 e5             	mov    %sp,%bp
    a7ba:	66 57                	push   %di
    a7bc:	66 56                	push   %si
    a7be:	66 53                	push   %bx
    a7c0:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    a7c5:	67 66 8b 7d 0c       	mov    0xc(%di),%di
    auto len1 = strlen(_s1);
    a7ca:	66 51                	push   %cx
    a7cc:	66 e8 85 ff          	callw  a755 <_Z6memsetPvim+0x23>
    a7d0:	ff                   	(bad)  
    a7d1:	ff 66 89             	jmp    *-0x77(%esi)
    a7d4:	c3                   	ret    
    auto len2 = strlen(_s2);
    a7d5:	67 66 89 3c          	mov    %di,(%si)
    a7d9:	24 66                	and    $0x66,%al
    a7db:	e8 77 ff ff ff       	call   a757 <_Z6strlenPKc>
    a7e0:	66 5a                	pop    %dx
    a7e2:	66 89 c6             	mov    %ax,%si
    auto len = len1 < len2 ? len1 : len2;
    auto ret = memcmp(reinterpret_cast<const void*>(_s1), reinterpret_cast<const void *>(_s2), len);
    a7e5:	66 39 c3             	cmp    %ax,%bx
    a7e8:	77 03                	ja     a7ed <_Z6strcmpPKcS0_+0x38>
    a7ea:	66 89 d8             	mov    %bx,%ax
    a7ed:	66 50                	push   %ax
    a7ef:	66 57                	push   %di
    a7f1:	66 51                	push   %cx
    a7f3:	66 e8 87 fe          	callw  a67e <_Z6printfPKcz+0x3c>
    a7f7:	ff                   	(bad)  
    a7f8:	ff 66 83             	jmp    *-0x7d(%esi)
    a7fb:	c4 0c 66             	les    (%esi,%eiz,2),%ecx
    if(ret == 0)
    a7fe:	85 c0                	test   %eax,%eax
    a800:	75 11                	jne    a813 <_Z6strcmpPKcS0_+0x5e>
    {
        if(len1 == len2)
    a802:	66 39 f3             	cmp    %si,%bx
    a805:	74 0c                	je     a813 <_Z6strcmpPKcS0_+0x5e>
        {
            return -1;
        }
        else
        {
            return 1;
    a807:	66 39 de             	cmp    %bx,%si
    a80a:	66 19 c0             	sbb    %ax,%ax
    a80d:	66 83 e0 02          	and    $0x2,%ax
    a811:	66 48                	dec    %ax
        }
    }
    return ret;
}
    a813:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    a818:	66 5b                	pop    %bx
    a81a:	66 5e                	pop    %si
    a81c:	66 5f                	pop    %di
    a81e:	66 5d                	pop    %bp
    a820:	66 c3                	retw   

0000a822 <_Z7reversePc>:

void reverse(char* buffer)
{
    a822:	66 55                	push   %bp
    a824:	66 89 e5             	mov    %sp,%bp
    a827:	66 56                	push   %si
    a829:	66 53                	push   %bx
    a82b:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    char ch;
    size_t len = strlen(buffer);
    a830:	66 51                	push   %cx
    a832:	66 e8 1f ff          	callw  a755 <_Z6memsetPvim+0x23>
    a836:	ff                   	(bad)  
    a837:	ff 66 5a             	jmp    *0x5a(%esi)
    a83a:	66 89 ca             	mov    %cx,%dx
    a83d:	67 66 8d 0c          	lea    (%si),%cx
    a841:	01 66 d1             	add    %esp,-0x2f(%esi)
    for(size_t i = 0; i < len / 2; ++i)
    a844:	e8 67 66 8d 34       	call   348e0eb0 <_GLOBAL_OFFSET_TABLE_+0x348d4d90>
    a849:	10 66 49             	adc    %ah,0x49(%esi)
    a84c:	66 39 f2             	cmp    %si,%dx
    a84f:	74 10                	je     a861 <_Z7reversePc+0x3f>
    {
        ch = *(buffer + i);
    a851:	67 8a 1a             	mov    (%bp,%si),%bl
        *(buffer + i) = *(buffer + len - 1 - i);
    a854:	67 8a 01             	mov    (%bx,%di),%al
    a857:	67 88 02             	mov    %al,(%bp,%si)
        *(buffer + len - 1 - i)  = ch;
    a85a:	67 88 19             	mov    %bl,(%bx,%di)
    a85d:	66 42                	inc    %dx
    for(size_t i = 0; i < len / 2; ++i)
    a85f:	eb e9                	jmp    a84a <_Z7reversePc+0x28>
    }
}
    a861:	67 66 8d 65 f8       	lea    -0x8(%di),%sp
    a866:	66 5b                	pop    %bx
    a868:	66 5e                	pop    %si
    a86a:	66 5d                	pop    %bp
    a86c:	66 c3                	retw   

0000a86e <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0>:
    if(base == 0 && !auto_detected)
    {
        base = 10;
        auto_detected = true;
    }
    auto char_to_digit = [](auto ch){
    a86e:	66 55                	push   %bp
    a870:	66 89 e5             	mov    %sp,%bp
    a873:	66 89 c2             	mov    %ax,%dx
        int digit;
        if(ch >= '0' && ch <= '9')
    a876:	66 83 e8 30          	sub    $0x30,%ax
    a87a:	3c 09                	cmp    $0x9,%al
    a87c:	77 0b                	ja     a889 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x1b>
            digit = ch - '0';
    a87e:	66 0f be d2          	movsbw %dl,%dx
    a882:	67 66 8d 42 d0       	lea    -0x30(%bp,%si),%ax
    a887:	eb 2b                	jmp    a8b4 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x46>
        else if(ch >='A' && ch <= 'F')
    a889:	67 66 8d 42 bf       	lea    -0x41(%bp,%si),%ax
    a88e:	3c 05                	cmp    $0x5,%al
    a890:	77 0b                	ja     a89d <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x2f>
            digit = ch - 'A' + 10;
    a892:	66 0f be d2          	movsbw %dl,%dx
    a896:	67 66 8d 42 c9       	lea    -0x37(%bp,%si),%ax
    a89b:	eb 17                	jmp    a8b4 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x46>
        else if(ch >='a' && ch <= 'f')
    a89d:	67 66 8d 4a 9f       	lea    -0x61(%bp,%si),%cx
            digit = ch - 'a' + 10;
        else
            digit = -1;
    a8a2:	66 83 c8 ff          	or     $0xffff,%ax
        else if(ch >='a' && ch <= 'f')
    a8a6:	80 f9 05             	cmp    $0x5,%cl
    a8a9:	77 09                	ja     a8b4 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x46>
            digit = ch - 'a' + 10;
    a8ab:	66 0f be d2          	movsbw %dl,%dx
    a8af:	67 66 8d 42 a9       	lea    -0x57(%bp,%si),%ax
        return digit;
    };
    a8b4:	66 5d                	pop    %bp
    a8b6:	66 c3                	retw   

0000a8b8 <_Z6strtolPKcPPci>:
{
    a8b8:	66 55                	push   %bp
    a8ba:	66 89 e5             	mov    %sp,%bp
    a8bd:	66 57                	push   %di
    a8bf:	66 56                	push   %si
    a8c1:	66 53                	push   %bx
    a8c3:	66 83 ec 0c          	sub    $0xc,%sp
    a8c7:	67 66 8b 75 10       	mov    0x10(%di),%si
    auto start = str;   
    a8cc:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    while(isspace(*start))
    a8d1:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    a8d6:	66 50                	push   %ax
    a8d8:	66 e8 2c f8          	callw  a108 <_start+0x8>
    a8dc:	ff                   	(bad)  
    a8dd:	ff 66 5f             	jmp    *0x5f(%esi)
    a8e0:	66 85 c0             	test   %ax,%ax
    a8e3:	74 04                	je     a8e9 <_Z6strtolPKcPPci+0x31>
        ++start;
    a8e5:	66 43                	inc    %bx
    while(isspace(*start))
    a8e7:	eb e8                	jmp    a8d1 <_Z6strtolPKcPPci+0x19>
    size_t len_num = strlen(start);//非白空格数字串长度
    a8e9:	66 53                	push   %bx
    a8eb:	66 e8 66 fe          	callw  a755 <_Z6memsetPvim+0x23>
    a8ef:	ff                   	(bad)  
    a8f0:	ff 66 59             	jmp    *0x59(%esi)
    if(len_num == 0)
    a8f3:	66 85 c0             	test   %ax,%ax
    a8f6:	75 1e                	jne    a916 <_Z6strtolPKcPPci+0x5e>
        return 0;
    a8f8:	66 31 c0             	xor    %ax,%ax
        if(str_end) *str_end = const_cast<char*>(str);
    a8fb:	67 66 83 7d 0c 00    	cmpw   $0x0,0xc(%di)
    a901:	0f 84 4d 01 67 66    	je     6667aa54 <_GLOBAL_OFFSET_TABLE_+0x6666e934>
    a907:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a90a:	67 66 8b 75 08       	mov    0x8(%di),%si
    a90f:	67 66 89 37          	mov    %si,(%bx)
    a913:	e9 3c 01 67 8a       	jmp    8a67aa54 <_GLOBAL_OFFSET_TABLE_+0x8a66e934>
    if(*high == '+' || *high == '-')
    a918:	13 80 fa 2b 74 10    	adc    0x10742bfa(%eax),%eax
    a91e:	80 fa 2d             	cmp    $0x2d,%dl
    a921:	75 21                	jne    a944 <_Z6strtolPKcPPci+0x8c>
        sign = (*high == '+') ? 1 : -1;
    a923:	67 66 c7 45 f0 ff ff 	movw   $0xffff,-0x10(%di)
    a92a:	ff                   	(bad)  
    a92b:	ff                   	(bad)  
    a92c:	eb 09                	jmp    a937 <_Z6strtolPKcPPci+0x7f>
    a92e:	67 66 c7 45 f0 01 00 	movw   $0x1,-0x10(%di)
    a935:	00 00                	add    %al,(%eax)
        ++high;
    a937:	67 66 8d 7b 01       	lea    0x1(%bp,%di),%di
        sign_char_bit = 1;
    a93c:	66 ba 01 00          	mov    $0x1,%dx
    a940:	00 00                	add    %al,(%eax)
    a942:	eb 0f                	jmp    a953 <_Z6strtolPKcPPci+0x9b>
    a944:	66 89 df             	mov    %bx,%di
    size_t sign_char_bit = 0;
    a947:	66 31 d2             	xor    %dx,%dx
    int sign = 1;
    a94a:	67 66 c7 45 f0 01 00 	movw   $0x1,-0x10(%di)
    a951:	00 00                	add    %al,(%eax)
    if(base == 16 || (base == 0 && !auto_detected))
    a953:	66 f7 c6 ef ff       	test   $0xffef,%si
    a958:	ff                   	(bad)  
    a959:	ff 75 29             	pushl  0x29(%ebp)
        if(len_num > 1 + sign_char_bit && 
    a95c:	67 66 8d 4a 01       	lea    0x1(%bp,%si),%cx
    a961:	66 39 c1             	cmp    %ax,%cx
    a964:	73 1f                	jae    a985 <_Z6strtolPKcPPci+0xcd>
    a966:	67 80 3f 30          	cmpb   $0x30,(%bx)
    a96a:	75 19                	jne    a985 <_Z6strtolPKcPPci+0xcd>
           (*(high + 1) == 'x' || *(high + 1) == 'X'))
    a96c:	67 8a 4f 01          	mov    0x1(%bx),%cl
    a970:	66 83 e1 df          	and    $0xffdf,%cx
    a974:	80 f9 58             	cmp    $0x58,%cl
    a977:	75 0c                	jne    a985 <_Z6strtolPKcPPci+0xcd>
             high += 2;
    a979:	66 83 c7 02          	add    $0x2,%di
             base = 16;
    a97d:	66 be 10 00          	mov    $0x10,%si
    a981:	00 00                	add    %al,(%eax)
    a983:	eb 2b                	jmp    a9b0 <_Z6strtolPKcPPci+0xf8>
    if(base == 8 || (base == 0 && !auto_detected))
    a985:	66 83 fe 08          	cmp    $0x8,%si
    a989:	74 05                	je     a990 <_Z6strtolPKcPPci+0xd8>
    a98b:	66 85 f6             	test   %si,%si
    a98e:	75 20                	jne    a9b0 <_Z6strtolPKcPPci+0xf8>
        if(len_num > sign_char_bit && *high == 0)   //存在八进制前缀0
    a990:	66 39 c2             	cmp    %ax,%dx
    a993:	73 10                	jae    a9a5 <_Z6strtolPKcPPci+0xed>
    a995:	67 80 3f 00          	cmpb   $0x0,(%bx)
    a999:	75 0a                	jne    a9a5 <_Z6strtolPKcPPci+0xed>
            high += 1;
    a99b:	66 47                	inc    %di
            base = 8;
    a99d:	66 be 08 00          	mov    $0x8,%si
    a9a1:	00 00                	add    %al,(%eax)
    a9a3:	eb 0b                	jmp    a9b0 <_Z6strtolPKcPPci+0xf8>
    if(base == 0 && !auto_detected)
    a9a5:	66 85 f6             	test   %si,%si
    a9a8:	75 06                	jne    a9b0 <_Z6strtolPKcPPci+0xf8>
        base = 10;
    a9aa:	66 be 0a 00          	mov    $0xa,%si
    a9ae:	00 00                	add    %al,(%eax)
    bool has_vaild_char = false;
    a9b0:	67 c6 45 ec 00       	movb   $0x0,-0x14(%di)
    auto low = start;   
    //使low指向数字低位后的一个位置
    while(!isspace(*low) &&             //判断是否是白空格
    a9b5:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    a9ba:	66 50                	push   %ax
    a9bc:	66 e8 48 f7          	callw  a108 <_start+0x8>
    a9c0:	ff                   	(bad)  
    a9c1:	ff 66 5a             	jmp    *0x5a(%esi)
          (*low != '\0') &&             //判断是否字符串结束
          char_to_digit(*low) != -1 &&  //判断是否是合法数字
    a9c4:	66 85 c0             	test   %ax,%ax
    a9c7:	75 28                	jne    a9f1 <_Z6strtolPKcPPci+0x139>
          (*low != '\0') &&             //判断是否字符串结束
    a9c9:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    while(!isspace(*low) &&             //判断是否是白空格
    a9ce:	84 c0                	test   %al,%al
    a9d0:	74 1f                	je     a9f1 <_Z6strtolPKcPPci+0x139>
          char_to_digit(*low) != -1 &&  //判断是否是合法数字
    a9d2:	66 e8 96 fe          	callw  a86c <_Z7reversePc+0x4a>
    a9d6:	ff                   	(bad)  
    a9d7:	ff 66 83             	jmp    *-0x7d(%esi)
          (*low != '\0') &&             //判断是否字符串结束
    a9da:	f8                   	clc    
    a9db:	ff 0f                	decl   (%edi)
    a9dd:	95                   	xchg   %eax,%ebp
    a9de:	c2 66 39             	ret    $0x3966
          char_to_digit(*low) != -1 &&  //判断是否是合法数字
    a9e1:	f0 0f 9c c0          	lock setl %al
    a9e5:	20 c2                	and    %al,%dl
    a9e7:	74 08                	je     a9f1 <_Z6strtolPKcPPci+0x139>
          char_to_digit(*low) < base    //判断是否是该进制
          )
    {
        ++low;
    a9e9:	66 43                	inc    %bx
        has_vaild_char = true;
    a9eb:	67 88 55 ec          	mov    %dl,-0x14(%di)
    while(!isspace(*low) &&             //判断是否是白空格
    a9ef:	eb c4                	jmp    a9b5 <_Z6strtolPKcPPci+0xfd>
    }
    if(!has_vaild_char)
    a9f1:	67 80 7d ec 00       	cmpb   $0x0,-0x14(%di)
    a9f6:	0f 84 fe fe 67 66    	je     6668a8fa <_GLOBAL_OFFSET_TABLE_+0x6667e7da>
        if (str_end) *str_end = const_cast<char*>(str);
        return 0;
    }
    long power = 1;
    long ret = 0;
    if(str_end) *str_end = const_cast<char*>(low);
    a9fc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    aa00:	74 09                	je     aa0b <_Z6strtolPKcPPci+0x153>
    aa02:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    aa07:	67 66 89 18          	mov    %bx,(%bx,%si)
    for(auto p = low - 1; p >= high; --p)
    aa0b:	66 4b                	dec    %bx
    long ret = 0;
    aa0d:	66 31 c9             	xor    %cx,%cx
    long power = 1;
    aa10:	66 ba 01 00          	mov    $0x1,%dx
    aa14:	00 00                	add    %al,(%eax)
    aa16:	67 66 89 55 e8       	mov    %dx,-0x18(%di)
    for(auto p = low - 1; p >= high; --p)
    aa1b:	66 39 fb             	cmp    %di,%bx
    aa1e:	72 29                	jb     aa49 <_Z6strtolPKcPPci+0x191>
    aa20:	67 66 89 4d ec       	mov    %cx,-0x14(%di)
    {
        int digit = char_to_digit(*p);
    aa25:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    aa2a:	66 e8 3e fe          	callw  a86c <_Z7reversePc+0x4a>
    aa2e:	ff                   	(bad)  
    aa2f:	ff 67 66             	jmp    *0x66(%edi)
        ret += power * digit;
    aa32:	8b 55 e8             	mov    -0x18(%ebp),%edx
    aa35:	66 0f af c2          	imul   %dx,%ax
    aa39:	67 66 8b 4d ec       	mov    -0x14(%di),%cx
    aa3e:	66 01 c1             	add    %ax,%cx
        
        power *= base;
    aa41:	66 0f af d6          	imul   %si,%dx
    for(auto p = low - 1; p >= high; --p)
    aa45:	66 4b                	dec    %bx
    aa47:	eb cd                	jmp    aa16 <_Z6strtolPKcPPci+0x15e>
    }
    ret *= sign;
    aa49:	67 66 8b 45 f0       	mov    -0x10(%di),%ax
    aa4e:	66 0f af c1          	imul   %cx,%ax
    return ret;
}
    aa52:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    aa57:	66 5b                	pop    %bx
    aa59:	66 5e                	pop    %si
    aa5b:	66 5f                	pop    %di
    aa5d:	66 5d                	pop    %bp
    aa5f:	66 c3                	retw   

Disassembly of section .text.startup:

0000aa61 <main>:
    }

};

extern "C" void main()
{
    aa61:	66 55                	push   %bp
    aa63:	66 89 e5             	mov    %sp,%bp
    aa66:	66 57                	push   %di
    aa68:	66 56                	push   %si
    aa6a:	66 53                	push   %bx
    aa6c:	66 81 ec b0 00       	sub    $0xb0,%sp
    aa71:	00 00                	add    %al,(%eax)
    char infix[SIZE];
    printf("Basic calculate 1.0\n");
    aa73:	66 68 d0 c0          	pushw  $0xc0d0
    aa77:	00 00                	add    %al,(%eax)
    aa79:	66 e8 c3 fb          	callw  a640 <_Z7sprintfPcPKcz+0x1e>
    aa7d:	ff                   	(bad)  
    aa7e:	ff 67 66             	jmp    *0x66(%edi)
    gets(infix);
    aa81:	8d b5 56 ff ff ff    	lea    -0xaa(%ebp),%esi
    aa87:	67 66 89 34          	mov    %si,(%si)
    aa8b:	24 66                	and    $0x66,%al
    aa8d:	e8 82 f7 ff ff       	call   a214 <_Z4getsPc>
    printf("Here\n");
    aa92:	67 66 c7 04 24 e5    	movw   $0xe524,(%si)
    aa98:	c0 00 00             	rolb   $0x0,(%eax)
    aa9b:	66 e8 a1 fb          	callw  a640 <_Z7sprintfPcPKcz+0x1e>
    aa9f:	ff                   	(bad)  
    aaa0:	ff 66 59             	jmp    *0x59(%esi)
        char* j = source;
    aaa3:	66 89 f2             	mov    %si,%dx
        char* i = source;
    aaa6:	66 89 f0             	mov    %si,%ax
        while (*j != 0) {
    aaa9:	67 8a 0a             	mov    (%bp,%si),%cl
    aaac:	84 c9                	test   %cl,%cl
    aaae:	74 0e                	je     aabe <main+0x5d>
            *i = *j++;
    aab0:	66 42                	inc    %dx
    aab2:	67 88 08             	mov    %cl,(%bx,%si)
            if (*i != ' ')
    aab5:	80 f9 20             	cmp    $0x20,%cl
    aab8:	74 ef                	je     aaa9 <main+0x48>
                i++;
    aaba:	66 40                	inc    %ax
    aabc:	eb eb                	jmp    aaa9 <main+0x48>
        *i = 0;
    aabe:	67 c6 00 00          	movb   $0x0,(%bx,%si)
        s[++top] = elem;
    aac2:	67 c6 45 88 23       	movb   $0x23,-0x78(%di)
    aac7:	66 31 ff             	xor    %di,%di
        int i = 0, k = 0;
    aaca:	66 31 db             	xor    %bx,%bx
        while ((ch = infix[i++]) != '\n') {
    aacd:	67 8a 16 80 fa       	mov    -0x580,%dl
    aad2:	0a 0f                	or     (%edi),%cl
    aad4:	84 eb                	test   %ch,%bl
    aad6:	00 80 fa 28 75 0c    	add    %al,0xc7528fa(%eax)
        s[++top] = elem;
    aadc:	66 47                	inc    %di
    aade:	67 c6 44 3d 88       	movb   $0x88,0x3d(%si)
    aae3:	28 66 46             	sub    %ah,0x46(%esi)
    aae6:	eb e5                	jmp    aacd <main+0x6c>
            else if (isalnum(ch))
    aae8:	66 0f be c2          	movsbw %dl,%ax
    aaec:	67 88 95 50 ff       	mov    %dl,-0xb0(%di)
    aaf1:	ff                   	(bad)  
    aaf2:	ff 66 50             	jmp    *0x50(%esi)
    aaf5:	66 e8 37 f6          	callw  a130 <_Z7isspacei+0x26>
    aaf9:	ff                   	(bad)  
    aafa:	ff 66 5a             	jmp    *0x5a(%esi)
    aafd:	66 85 c0             	test   %ax,%ax
    ab00:	67 8a 95 50 ff       	mov    -0xb0(%di),%dl
    ab05:	ff                   	(bad)  
    ab06:	ff 74 09 67          	pushl  0x67(%ecx,%ecx,1)
                postfix[k++] = ch;
    ab0a:	88 54 1d c0          	mov    %dl,-0x40(%ebp,%ebx,1)
    ab0e:	66 43                	inc    %bx
    ab10:	eb d2                	jmp    aae4 <main+0x83>
            else if (ch == ')') {
    ab12:	80 fa 29             	cmp    $0x29,%dl
    ab15:	74 1a                	je     ab31 <main+0xd0>
    ab17:	67 66 8d 42 dd       	lea    -0x23(%bp,%si),%ax
    ab1c:	67 88 85 50 ff       	mov    %al,-0xb0(%di)
    ab21:	ff                   	(bad)  
    ab22:	ff 66 0f             	jmp    *0xf(%esi)
    ab25:	b6 c0                	mov    $0xc0,%dh
    ab27:	67 66 89 85 44 ff    	mov    %ax,-0xbc(%di)
    ab2d:	ff                   	(bad)  
    ab2e:	ff                   	(bad)  
    ab2f:	eb 46                	jmp    ab77 <main+0x116>
                while (s[top] != '(')
    ab31:	67 8a 44 3d          	mov    0x3d(%si),%al
    ab35:	88 66 4f             	mov    %ah,0x4f(%esi)
    ab38:	3c 28                	cmp    $0x28,%al
    ab3a:	74 a8                	je     aae4 <main+0x83>
                    postfix[k++] = pop();
    ab3c:	66 43                	inc    %bx
    ab3e:	67 88 44 1d          	mov    %al,0x1d(%si)
    ab42:	bf eb ec 66 83       	mov    $0x8366eceb,%edi
        switch (elem) {
    ab47:	c8 ff 67 80          	enter  $0x67ff,$0x80
    ab4b:	bd 50 ff ff ff       	mov    $0xffffff50,%ebp
    ab50:	0c 77                	or     $0x77,%al
    ab52:	11 67 66             	adc    %esp,0x66(%edi)
    ab55:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
    ab5b:	67 66 0f be 80 f0 c0 	movsbw -0x3f10(%bx,%si),%ax
    ab62:	00 00                	add    %al,(%eax)
    ab64:	66 4f                	dec    %di
                while (pr(s[top]) >= pr(ch))
    ab66:	67 66 3b 85 4c ff    	cmp    -0xb4(%di),%ax
    ab6c:	ff                   	(bad)  
    ab6d:	ff                   	(bad)  
    ab6e:	7f 40                	jg     abb0 <main+0x14f>
                    postfix[k++] = pop();
    ab70:	66 43                	inc    %bx
    ab72:	67 88 4c 1d          	mov    %cl,0x1d(%si)
    ab76:	bf 67 66 89 bd       	mov    $0xbd896667,%edi
    ab7b:	48                   	dec    %eax
    ab7c:	ff                   	(bad)  
    ab7d:	ff                   	(bad)  
    ab7e:	ff 67 8a             	jmp    *-0x76(%edi)
                while (pr(s[top]) >= pr(ch))
    ab81:	4c                   	dec    %esp
    ab82:	3d 88 67 66 8d       	cmp    $0x8d666788,%eax
    ab87:	41                   	inc    %ecx
    ab88:	dd 67 66             	frstor 0x66(%edi)
        switch (elem) {
    ab8b:	c7 85 4c ff ff ff ff 	movl   $0xffffffff,-0xb4(%ebp)
    ab92:	ff ff ff 
    ab95:	3c 0c                	cmp    $0xc,%al
    ab97:	77 ac                	ja     ab45 <main+0xe4>
    ab99:	66 0f b6 c0          	movzbw %al,%ax
    ab9d:	67 66 0f be 80 f0 c0 	movsbw -0x3f10(%bx,%si),%ax
    aba4:	00 00                	add    %al,(%eax)
    aba6:	67 66 89 85 4c ff    	mov    %ax,-0xb4(%di)
    abac:	ff                   	(bad)  
    abad:	ff                   	(bad)  
    abae:	eb 95                	jmp    ab45 <main+0xe4>
        s[++top] = elem;
    abb0:	67 66 8b bd 48 ff    	mov    -0xb8(%di),%di
    abb6:	ff                   	(bad)  
    abb7:	ff 66 47             	jmp    *0x47(%esi)
    abba:	67 88 54 3d          	mov    %dl,0x3d(%si)
    abbe:	88 e9                	mov    %ch,%cl
    abc0:	22 ff                	and    %bh,%bh
        while (s[top] != '#')
    abc2:	67 8a 44 3d          	mov    0x3d(%si),%al
    abc6:	88 3c 23             	mov    %bh,(%ebx,%eiz,1)
    abc9:	74 0b                	je     abd6 <main+0x175>
        return (s[top--]);
    abcb:	66 4f                	dec    %di
            postfix[k++] = pop();
    abcd:	66 43                	inc    %bx
    abcf:	67 88 44 1d          	mov    %al,0x1d(%si)
    abd3:	bf eb ec 67 c6       	mov    $0xc667eceb,%edi
        postfix[k] = 0;
    abd8:	44                   	inc    %esp
    abd9:	1d c0 00 66 68       	sbb    $0x686600c0,%eax
    calc c(infix);
    printf("Here\n");
    abde:	e5 c0                	in     $0xc0,%eax
    abe0:	00 00                	add    %al,(%eax)
    abe2:	66 e8 5a fa          	callw  a640 <_Z7sprintfPcPKcz+0x1e>
    abe6:	ff                   	(bad)  
    abe7:	ff 67 66             	jmp    *0x66(%edi)
    abea:	8d 75 88             	lea    -0x78(%ebp),%esi
    abed:	66 5b                	pop    %bx
        while ((ch = postfix[i++]) != 0) {
    abef:	67 8a 5e 38          	mov    0x38(%bp),%bl
    abf3:	84 db                	test   %bl,%bl
    abf5:	0f 84 8d 00 66 0f    	je     f66ac88 <_GLOBAL_OFFSET_TABLE_+0xf65eb68>
            putchar(ch);
    abfb:	be d3 66 52 67       	mov    $0x675266d3,%esi
    ac00:	66 89 95 50 ff ff ff 	mov    %dx,-0xb0(%ebp)
    ac07:	66 e8 9b f5          	callw  a1a6 <_ZL19system_call_putchari+0x29>
    ac0b:	ff                   	(bad)  
    ac0c:	ff 67 66             	jmp    *0x66(%edi)
            if (isdigit(ch))
    ac0f:	8b 95 50 ff ff ff    	mov    -0xb0(%ebp),%edx
    ac15:	67 66 89 14          	mov    %dx,(%si)
    ac19:	24 66                	and    $0x66,%al
    ac1b:	e8 40 f5 ff ff       	call   a160 <_Z7isdigiti>
    ac20:	66 59                	pop    %cx
    ac22:	66 85 c0             	test   %ax,%ax
    ac25:	74 15                	je     ac3c <main+0x1db>
        s[++top] = elem;
    ac27:	67 66 8d 4f 01       	lea    0x1(%bx),%cx
                push(ch - '0');
    ac2c:	66 83 eb 30          	sub    $0x30,%bx
    ac30:	67 88 5c 0d          	mov    %bl,0xd(%si)
    ac34:	88 66 46             	mov    %ah,0x46(%esi)
        switch (elem) {
    ac37:	66 89 cf             	mov    %cx,%di
    ac3a:	eb b3                	jmp    abef <main+0x18e>
        return (s[top--]);
    ac3c:	67 66 8d 4f ff       	lea    -0x1(%bx),%cx
    ac41:	67 8a 54 3d          	mov    0x3d(%si),%dl
    ac45:	88 67 66             	mov    %ah,0x66(%edi)
    ac48:	0f be 44 0d 88       	movsbl -0x78(%ebp,%ecx,1),%eax
                switch (ch) {
    ac4d:	80 fb 2b             	cmp    $0x2b,%bl
    ac50:	74 25                	je     ac77 <main+0x216>
    ac52:	7f 0e                	jg     ac62 <main+0x201>
                        push(op1 * op2);
    ac54:	f6 e2                	mul    %dl
                switch (ch) {
    ac56:	80 fb 2a             	cmp    $0x2a,%bl
    ac59:	74 24                	je     ac7f <main+0x21e>
        return (s[top--]);
    ac5b:	67 66 8d 4f fe       	lea    -0x2(%bx),%cx
    ac60:	eb d3                	jmp    ac35 <main+0x1d4>
                switch (ch) {
    ac62:	80 fb 2d             	cmp    $0x2d,%bl
    ac65:	74 15                	je     ac7c <main+0x21b>
    ac67:	80 fb 2f             	cmp    $0x2f,%bl
    ac6a:	75 ef                	jne    ac5b <main+0x1fa>
                op2 = pop();
    ac6c:	66 0f be da          	movsbw %dl,%bx
                        push(op1 / op2);
    ac70:	66 99                	cwtd   
    ac72:	66 f7 fb             	idiv   %bx
    ac75:	eb 08                	jmp    ac7f <main+0x21e>
                        push(op1 + op2);
    ac77:	66 01 d0             	add    %dx,%ax
    ac7a:	eb 03                	jmp    ac7f <main+0x21e>
                        push(op1 - op2);
    ac7c:	66 29 d0             	sub    %dx,%ax
                        push(op1 / op2);
    ac7f:	67 88 44 0d          	mov    %al,0xd(%si)
    ac83:	88 eb                	mov    %ch,%bl
    ac85:	af                   	scas   %es:(%edi),%eax
        return s[top];
    ac86:	67 66 0f be 44 3d    	movsbw 0x3d(%si),%ax
    ac8c:	88 66 50             	mov    %ah,0x50(%esi)
    printf("%d\n", c.eval_postfix());
    ac8f:	66 68 eb c0          	pushw  $0xc0eb
    ac93:	00 00                	add    %al,(%eax)
    ac95:	66 e8 a7 f9          	callw  a640 <_Z7sprintfPcPKcz+0x1e>
    ac99:	ff                   	(bad)  
    ac9a:	ff 66 58             	jmp    *0x58(%esi)
}
    ac9d:	66 5a                	pop    %dx
    ac9f:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    aca4:	66 5b                	pop    %bx
    aca6:	66 5e                	pop    %si
    aca8:	66 5f                	pop    %di
    acaa:	66 5d                	pop    %bp
    acac:	66 c3                	retw   

Disassembly of section .text._Z4itoaIjEvPcT_ib:

0000acae <_Z4itoaIjEvPcT_ib>:
void itoa(char* buffer, T num, int base, bool captial = false)
    acae:	66 55                	push   %bp
    acb0:	66 89 e5             	mov    %sp,%bp
    acb3:	66 57                	push   %di
    acb5:	66 56                	push   %si
    acb7:	66 53                	push   %bx
    acb9:	66 83 ec 08          	sub    $0x8,%sp
    acbd:	67 66 8b 75 08       	mov    0x8(%di),%si
    acc2:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    acc7:	67 66 8b 7d 10       	mov    0x10(%di),%di
    accc:	67 8a 5d 14          	mov    0x14(%di),%bl
    acd0:	67 88 5d ef          	mov    %bl,-0x11(%di)
    char *p = buffer;
    acd4:	66 89 f1             	mov    %si,%cx
    acd7:	66 31 d2             	xor    %dx,%dx
    acda:	66 f7 f7             	div    %di
    acdd:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
        *(p++) = captial ? num_char_upper[mod] : num_char_lower[mod];
    ace2:	67 80 7d ef 00       	cmpb   $0x0,-0x11(%di)
    ace7:	74 09                	je     acf2 <_Z4itoaIjEvPcT_ib+0x44>
    ace9:	67 8a 9a fd c0       	mov    -0x3f03(%bp,%si),%bl
    acee:	00 00                	add    %al,(%eax)
    acf0:	eb 07                	jmp    acf9 <_Z4itoaIjEvPcT_ib+0x4b>
    acf2:	67 8a 9a 0e c1       	mov    -0x3ef2(%bp,%si),%bl
    acf7:	00 00                	add    %al,(%eax)
    acf9:	67 66 8d 51 01       	lea    0x1(%bx,%di),%dx
    acfe:	67 88 5a ff          	mov    %bl,-0x1(%bp,%si)
        if(num == 0) break;
    ad02:	67 66 83 7d f0 00    	cmpw   $0x0,-0x10(%di)
    ad08:	74 05                	je     ad0f <_Z4itoaIjEvPcT_ib+0x61>
    ad0a:	66 89 d1             	mov    %dx,%cx
    ad0d:	eb c8                	jmp    acd7 <_Z4itoaIjEvPcT_ib+0x29>
    *p = '\0';
    ad0f:	67 c6 41 01 00       	movb   $0x0,0x1(%bx,%di)
    reverse(buffer);
    ad14:	67 66 89 75 08       	mov    %si,0x8(%di)
}
    ad19:	66 58                	pop    %ax
    ad1b:	66 5a                	pop    %dx
    ad1d:	66 5b                	pop    %bx
    ad1f:	66 5e                	pop    %si
    ad21:	66 5f                	pop    %di
    ad23:	66 5d                	pop    %bp
    reverse(buffer);
    ad25:	e9                   	.byte 0xe9
    ad26:	fa                   	cli    
    ad27:	fa                   	cli    
