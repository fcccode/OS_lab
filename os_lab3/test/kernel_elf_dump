
build/kernel/kernel.bin.elf:     file format elf32-i386


Disassembly of section .text:

00007e00 <_text>:
    7e00:	b0 34                	mov    $0x34,%al
    7e02:	e6 43                	out    %al,$0x43
    7e04:	b8 6f ba e6 40       	mov    $0x40e6ba6f,%eax
    7e09:	88 e0                	mov    %ah,%al
    7e0b:	e6 40                	out    %al,$0x40
    7e0d:	68 90 7e 6a 20       	push   $0x206a7e90
    7e12:	e8 5c 00 83 c4       	call   c4837e73 <_GLOBAL_OFFSET_TABLE_+0xc482c08b>
    7e17:	04 a1                	add    $0xa1,%al
    7e19:	24 00                	and    $0x0,%al
    7e1b:	a3 fd 7e a1 26       	mov    %eax,0x26a17efd
    7e20:	00 a3 ff 7e 68 0c    	add    %ah,0xc687eff(%ebx)
    7e26:	7f 6a                	jg     7e92 <interrupt_08h+0x2>
    7e28:	24 e8                	and    $0xe8,%al
    7e2a:	45                   	inc    %ebp
    7e2b:	00 83 c4 04 68 69    	add    %al,0x696804c4(%ebx)
    7e31:	7f 68                	jg     7e9b <interrupt_08h+0xb>
    7e33:	80 00 e8             	addb   $0xe8,(%eax)
    7e36:	39 00                	cmp    %eax,(%eax)
    7e38:	83 c4 04             	add    $0x4,%esp
    7e3b:	68 6b 7f 68 84       	push   $0x84687f6b
    7e40:	00 e8                	add    %ch,%al
    7e42:	2d 00 83 c4 04       	sub    $0x4c48300,%eax
    7e47:	68 bc 7f 68 cc       	push   $0xcc687fbc
    7e4c:	00 e8                	add    %ch,%al
    7e4e:	21 00                	and    %eax,(%eax)
    7e50:	83 c4 04             	add    $0x4,%esp
    7e53:	68 c3 7f 68 d0       	push   $0xd0687fc3
    7e58:	00 e8                	add    %ch,%al
    7e5a:	15 00 83 c4 04       	adc    $0x4c48300,%eax
    7e5f:	68 7b 7f 68 60       	push   $0x60687f7b
    7e64:	02 e8                	add    %al,%ch
    7e66:	09 00                	or     %eax,(%eax)
    7e68:	83 c4 04             	add    $0x4,%esp
    7e6b:	e8 45 02 fa eb       	call   ebfa80b5 <_GLOBAL_OFFSET_TABLE_+0xebf9c2cd>
    7e70:	fe                   	.byte 0xfe

00007e71 <install_int>:
    7e71:	55                   	push   %ebp
    7e72:	89 e5                	mov    %esp,%ebp
    7e74:	b8 00 00 8e c0       	mov    $0xc08e0000,%eax
    7e79:	8b 76 04             	mov    0x4(%esi),%esi
    7e7c:	8b 4e 06             	mov    0x6(%esi),%ecx
    7e7f:	26 89 0c 26          	mov    %ecx,%es:(%esi,%eiz,1)
    7e83:	8c 4c 02 8e          	mov    %cs,-0x72(%edx,%eax,1)
    7e87:	c0                   	.byte 0xc0
    7e88:	5d                   	pop    %ebp
    7e89:	c3                   	ret    

00007e8a <int_08_what_to_play>:
	...

00007e8c <sys_int08_arrive>:
    7e8c:	00 00                	add    %al,(%eax)
	...

00007e90 <interrupt_08h>:
    7e90:	fa                   	cli    
    7e91:	06                   	push   %es
    7e92:	60                   	pusha  
    7e93:	b0 01                	mov    $0x1,%al
    7e95:	86 06                	xchg   %al,(%esi)
    7e97:	8c 7e 8c             	mov    %?,-0x74(%esi)
    7e9a:	c8 8e c0 b9          	enter  $0xc08e,$0xb9
    7e9e:	00 b8 8e e9 b4 09    	add    %bh,0x9b4e98e(%eax)

00007ea4 <test_up>:
    7ea4:	26 83 3e 8a          	cmpl   $0xffffff8a,%es:(%esi)
    7ea8:	7e 10                	jle    7eba <test_left+0x5>
    7eaa:	7d 09                	jge    7eb5 <test_left>
    7eac:	b0 7c                	mov    $0x7c,%al
    7eae:	26 ff 06             	incl   %es:(%esi)
    7eb1:	8a 7e eb             	mov    -0x15(%esi),%bh
    7eb4:	3a                   	.byte 0x3a

00007eb5 <test_left>:
    7eb5:	26 83 3e 8a          	cmpl   $0xffffff8a,%es:(%esi)
    7eb9:	7e 20                	jle    7edb <test_down+0x4>
    7ebb:	7d 09                	jge    7ec6 <test_right>
    7ebd:	b0 2f                	mov    $0x2f,%al
    7ebf:	26 ff 06             	incl   %es:(%esi)
    7ec2:	8a 7e eb             	mov    -0x15(%esi),%bh
    7ec5:	29                   	.byte 0x29

00007ec6 <test_right>:
    7ec6:	26 83 3e 8a          	cmpl   $0xffffff8a,%es:(%esi)
    7eca:	7e 30                	jle    7efc <test_input_over+0xd>
    7ecc:	7d 09                	jge    7ed7 <test_down>
    7ece:	b0 2d                	mov    $0x2d,%al
    7ed0:	26 ff 06             	incl   %es:(%esi)
    7ed3:	8a 7e eb             	mov    -0x15(%esi),%bh
    7ed6:	18                   	.byte 0x18

00007ed7 <test_down>:
    7ed7:	26 83 3e 8a          	cmpl   $0xffffff8a,%es:(%esi)
    7edb:	7e 40                	jle    7f1d <interrupt_09h+0x11>
    7edd:	7d 09                	jge    7ee8 <reset_char>
    7edf:	b0 5c                	mov    $0x5c,%al
    7ee1:	26 ff 06             	incl   %es:(%esi)
    7ee4:	8a 7e eb             	mov    -0x15(%esi),%bh
    7ee7:	07                   	pop    %es

00007ee8 <reset_char>:
    7ee8:	26 c7 06 8a 7e 00 00 	movl   $0x7e8a,%es:(%esi)

00007eef <test_input_over>:
    7eef:	65 a3 52 00 b0 20    	mov    %eax,%gs:0x20b00052
    7ef5:	e6 20                	out    %al,$0x20
    7ef7:	e6 a0                	out    %al,$0xa0
    7ef9:	61                   	popa   
    7efa:	07                   	pop    %es
    7efb:	fb                   	sti    
    7efc:	cf                   	iret   

00007efd <int_09_saved>:
    7efd:	00 00                	add    %al,(%eax)
	...

00007f01 <ouchs>:
    7f01:	4f                   	dec    %edi
    7f02:	55                   	push   %ebp
    7f03:	43                   	inc    %ebx
    7f04:	48                   	dec    %eax
    7f05:	21 4f 55             	and    %ecx,0x55(%edi)
    7f08:	43                   	inc    %ebx
    7f09:	48                   	dec    %eax
    7f0a:	21                   	.byte 0x21

00007f0b <len_ouch>:
    7f0b:	0a                   	.byte 0xa

00007f0c <interrupt_09h>:
    7f0c:	60                   	pusha  
    7f0d:	b9 00 b8 8e e9       	mov    $0xe98eb800,%ecx
    7f12:	89 dd                	mov    %ebx,%ebp
    7f14:	b4 09                	mov    $0x9,%ah
    7f16:	b0 4f                	mov    $0x4f,%al
    7f18:	65 a3 3c 00 b0 55    	mov    %eax,%gs:0x55b0003c
    7f1e:	65 a3 3e 00 b0 43    	mov    %eax,%gs:0x43b0003e
    7f24:	65 a3 40 00 b0 48    	mov    %eax,%gs:0x48b00040
    7f2a:	65 a3 42 00 b0 53    	mov    %eax,%gs:0x53b00042
    7f30:	65 a3 44 00 b0 21    	mov    %eax,%gs:0x21b00044
    7f36:	65 a3 46 00 b0 4f    	mov    %eax,%gs:0x4fb00046
    7f3c:	65 a3 48 00 b0 55    	mov    %eax,%gs:0x55b00048
    7f42:	65 a3 4a 00 b0 43    	mov    %eax,%gs:0x43b0004a
    7f48:	65 a3 4c 00 b0 48    	mov    %eax,%gs:0x48b0004c
    7f4e:	65 a3 4e 00 b0 21    	mov    %eax,%gs:0x21b0004e
    7f54:	65 a3 50 00 61 06    	mov    %eax,%gs:0x6610050
    7f5a:	50                   	push   %eax
    7f5b:	8c c8                	mov    %cs,%eax
    7f5d:	8e c0                	mov    %eax,%es
    7f5f:	fb                   	sti    
    7f60:	9c                   	pushf  
    7f61:	26 ff 1e             	lcall  *%es:(%esi)
    7f64:	fd                   	std    
    7f65:	7e 58                	jle    7fbf <interrupt_33h+0x3>
    7f67:	07                   	pop    %es
    7f68:	cf                   	iret   

00007f69 <interrupt_20h>:
    7f69:	b4 4c                	mov    $0x4c,%ah

00007f6b <interrupt_21h>:
    7f6b:	80 fc 4c             	cmp    $0x4c,%ah
    7f6e:	75 09                	jne    7f79 <panic_21h_func_not_impl>
    7f70:	83 c4 06             	add    $0x6,%esp
    7f73:	66 ff 26             	jmpw   *(%esi)
    7f76:	0a                   	.byte 0xa
    7f77:	a0                   	.byte 0xa0
    7f78:	cf                   	iret   

00007f79 <panic_21h_func_not_impl>:
    7f79:	eb fe                	jmp    7f79 <panic_21h_func_not_impl>

00007f7b <interrupt_98h>:
    7f7b:	80 fc 00             	cmp    $0x0,%ah
    7f7e:	75 05                	jne    7f85 <func_01>

00007f80 <func_00>:
    7f80:	e8 66 02 eb 36       	call   36eb81eb <_GLOBAL_OFFSET_TABLE_+0x36eac403>

00007f85 <func_01>:
    7f85:	80 fc 01             	cmp    $0x1,%ah
    7f88:	75 0f                	jne    7f99 <func_02>
    7f8a:	60                   	pusha  
    7f8b:	66 50                	push   %ax
    7f8d:	66 e8 00 01          	callw  8091 <_Z19sys_get_current_ttyv+0xb>
    7f91:	00 00                	add    %al,(%eax)
    7f93:	83 c4 04             	add    $0x4,%esp
    7f96:	61                   	popa   
    7f97:	eb 22                	jmp    7fbb <func_03>

00007f99 <func_02>:
    7f99:	80 fc 02             	cmp    $0x2,%ah
    7f9c:	75 1d                	jne    7fbb <func_03>
    7f9e:	06                   	push   %es
    7f9f:	60                   	pusha  
    7fa0:	8c c8                	mov    %cs,%eax
    7fa2:	8e c0                	mov    %eax,%es
    7fa4:	fb                   	sti    

00007fa5 <sleep_loop>:
    7fa5:	26 80 3e 8c          	cmpb   $0x8c,%es:(%esi)
    7fa9:	7e 00                	jle    7fab <sleep_loop+0x6>
    7fab:	74 f8                	je     7fa5 <sleep_loop>
    7fad:	b8 00 00 26 86       	mov    $0x86260000,%eax
    7fb2:	06                   	push   %es
    7fb3:	8c 7e e2             	mov    %?,-0x1e(%esi)
    7fb6:	ee                   	out    %al,(%dx)
    7fb7:	61                   	popa   
    7fb8:	07                   	pop    %es
    7fb9:	eb 00                	jmp    7fbb <func_03>

00007fbb <func_03>:
    7fbb:	cf                   	iret   

00007fbc <interrupt_33h>:
    7fbc:	66 e8 64 05          	callw  8524 <sys_read_disk+0x61>
    7fc0:	00 00                	add    %al,(%eax)
    7fc2:	cf                   	iret   

00007fc3 <interrupt_34h>:
    7fc3:	66 e8 0b 06          	callw  85d2 <interrupt_33h_c+0xac>
    7fc7:	00 00                	add    %al,(%eax)
    7fc9:	cf                   	iret   

00007fca <_ZL8print_okPc>:
    int mask = 0x00FF;
    ch = ch & mask;
    sys_get_current_tty()->putchar(ch);
}
const char* str = "Welcome to HHOS version 1.2.0\nYou can input help to see how to use it!";
static inline void print_ok(char * mod) {
    7fca:	66 55                	push   %bp
    7fcc:	66 89 e5             	mov    %sp,%bp
    printf("%s init [", mod);
    7fcf:	66 50                	push   %ax
    7fd1:	66 68 14 ba          	pushw  $0xba14
    7fd5:	00 00                	add    %al,(%eax)
    7fd7:	66 e8 5f 16          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    7fdb:	00 00                	add    %al,(%eax)
    {
        cur_y = y;
    }
    void set_color(int _color)
    {
        color = _color;
    7fdd:	66 a1 20 aa 67 66    	mov    0x6667aa20,%ax
    7fe3:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
    current_tty->set_color(MAKE_COLOR(VGA_BLACK, VGA_GREEN));
    printf("OK");
    7fea:	66 58                	pop    %ax
    7fec:	66 5a                	pop    %dx
    7fee:	66 68 1e ba          	pushw  $0xba1e
    7ff2:	00 00                	add    %al,(%eax)
    7ff4:	66 e8 42 16          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    7ff8:	00 00                	add    %al,(%eax)
    7ffa:	66 a1 20 aa 67 66    	mov    0x6667aa20,%ax
    8000:	c7 40 08 07 00 00 00 	movl   $0x7,0x8(%eax)
    current_tty->set_color(MAKE_COLOR(VGA_BLACK, VGA_WHITE));
    printf("]\n");
    8007:	67 66 c7 04 24 21    	movw   $0x2124,(%si)
    800d:	ba 00 00 66 e8       	mov    $0xe8660000,%edx
    8012:	26 16                	es push %ss
    8014:	00 00                	add    %al,(%eax)
}
    8016:	66 59                	pop    %cx
    8018:	66 c9                	leavew 
    801a:	66 c3                	retw   

0000801c <_ZN3tty11move_cursorEii.isra.1>:
    }
    void move_cursor(int x, int y)
    801c:	66 55                	push   %bp
    801e:	66 89 e5             	mov    %sp,%bp
    8021:	66 53                	push   %bx
    {
        uint16_t pos = x * 80 + y;
    8023:	6b c0 50             	imul   $0x50,%eax,%eax
    8026:	67 66 8d 1c          	lea    (%si),%bx
    802a:	10 66 6a             	adc    %ah,0x6a(%esi)
        sys_outb(0x3D4, 0x0F);
    802d:	0f 66 68 d4          	pcmpgtd -0x2c(%eax),%mm5
    8031:	03 00                	add    (%eax),%eax
    8033:	00 66 e8             	add    %ah,-0x18(%esi)
    8036:	54                   	push   %esp
    8037:	04 00                	add    $0x0,%al
    8039:	00 66 58             	add    %ah,0x58(%esi)
        sys_outb(0x3D5, (uint8_t) (pos & 0xFF));
    803c:	66 5a                	pop    %dx
    803e:	66 0f b6 c3          	movzbw %bl,%ax
    8042:	66 50                	push   %ax
    8044:	66 68 d5 03          	pushw  $0x3d5
    8048:	00 00                	add    %al,(%eax)
    804a:	66 e8 3e 04          	callw  848c <sys_inb+0xd>
    804e:	00 00                	add    %al,(%eax)
        sys_outb(0x3D4, 0x0E);
    8050:	66 59                	pop    %cx
    8052:	66 58                	pop    %ax
    8054:	66 6a 0e             	pushw  $0xe
    8057:	66 68 d4 03          	pushw  $0x3d4
    805b:	00 00                	add    %al,(%eax)
    805d:	66 e8 2b 04          	callw  848c <sys_inb+0xd>
    8061:	00 00                	add    %al,(%eax)
        sys_outb(0x3D5, (uint8_t) ((pos >> 8) & 0xFF));
    8063:	66 58                	pop    %ax
    8065:	66 5a                	pop    %dx
    8067:	66 0f b6 df          	movzbw %bh,%bx
    806b:	66 53                	push   %bx
    806d:	66 68 d5 03          	pushw  $0x3d5
    8071:	00 00                	add    %al,(%eax)
    8073:	66 e8 15 04          	callw  848c <sys_inb+0xd>
    8077:	00 00                	add    %al,(%eax)
    8079:	66 59                	pop    %cx
    807b:	66 5b                	pop    %bx
    }
    807d:	67 66 8b 5d fc       	mov    -0x4(%di),%bx
    8082:	66 c9                	leavew 
    8084:	66 c3                	retw   

00008086 <_Z19sys_get_current_ttyv>:
tty* sys_get_current_tty(){return current_tty;}
    8086:	66 55                	push   %bp
    8088:	66 89 e5             	mov    %sp,%bp
    808b:	66 a1 20 aa 66 5d    	mov    0x5d66aa20,%ax
    8091:	66 c3                	retw   

00008093 <sys_current_tty_putchar>:
{
    8093:	66 55                	push   %bp
    8095:	66 89 e5             	mov    %sp,%bp
    ch = ch & mask;
    8098:	67 66 0f b6 45 08    	movzbw 0x8(%di),%ax
    sys_get_current_tty()->putchar(ch);
    809e:	66 50                	push   %ax
    80a0:	66 ff 36             	pushw  (%esi)
    80a3:	20 aa 66 e8 7f 16    	and    %ch,0x167fe866(%edx)
    80a9:	00 00                	add    %al,(%eax)
}
    80ab:	66 58                	pop    %ax
    80ad:	66 5a                	pop    %dx
    80af:	66 c9                	leavew 
    80b1:	66 c3                	retw   

000080b3 <kernel_main>:
extern "C" void kernel_main()
{
    80b3:	66 55                	push   %bp
    80b5:	66 89 e5             	mov    %sp,%bp
    80b8:	66 53                	push   %bx
    80ba:	66 81 ec d8 0d       	sub    $0xdd8,%sp
    80bf:	00 00                	add    %al,(%eax)
        sys_bios_clear_screen();
    80c1:	66 e8 0c 01          	callw  81d1 <sys_bios_print_string+0x21>
    80c5:	00 00                	add    %al,(%eax)
        tty_init();
    80c7:	67 66 8d 9d 24 f2    	lea    -0xddc(%di),%bx
    80cd:	ff                   	(bad)  
    80ce:	ff 66 53             	jmp    *0x53(%esi)
    80d1:	66 e8 1b 16          	callw  96f0 <_text_end+0x76>
    80d5:	00 00                	add    %al,(%eax)
    tty tty1;
    current_tty = &tty1;
    80d7:	66 89 1e             	mov    %bx,(%esi)
    80da:	20 aa 66 59 66 b8    	and    %ch,-0x4799a69a(%edx)
    print_ok("TTY");
    80e0:	24 ba                	and    $0xba,%al
    80e2:	00 00                	add    %al,(%eax)
    80e4:	66 e8 e0 fe          	callw  7fc8 <interrupt_34h+0x5>
    80e8:	ff                   	(bad)  
    80e9:	ff 67 66             	jmp    *0x66(%edi)
        return -1;
    }


public:
    sh(){
    80ec:	c7 85 30 f2 ff ff 08 	movl   $0x8,-0xdd0(%ebp)
    80f3:	00 00 00 
    80f6:	66 31 c0             	xor    %ax,%ax
    struct cmd{
    80f9:	67 66 8d 9d 30 f2    	lea    -0xdd0(%di),%bx
    80ff:	ff                   	(bad)  
    8100:	ff 67 66             	jmp    *0x66(%edi)
    8103:	c7 84 05 38 f3 ff ff 	movl   $0x0,-0xcc8(%ebp,%eax,1)
    810a:	00 00 00 00 
    810e:	66 83 c0 08          	add    $0x8,%ax
    sh(){
    8112:	66 3d 00 01          	cmp    $0x100,%ax
    8116:	00 00                	add    %al,(%eax)
    8118:	75 e7                	jne    8101 <kernel_main+0x4e>
    811a:	67 66 c7 85 b4 fd ff 	movw   $0xffff,-0x24c(%di)
    8121:	ff 
    8122:	00 00                	add    %al,(%eax)
    8124:	00 00                	add    %al,(%eax)
    8126:	67 66 c7 85 b8 fd ff 	movw   $0xffff,-0x248(%di)
    812d:	ff 
    812e:	00 00                	add    %al,(%eax)
    8130:	00 00                	add    %al,(%eax)
        memset(buf, 0, buf_size);
    8132:	66 68 80 00          	pushw  $0x80
    8136:	00 00                	add    %al,(%eax)
    8138:	66 6a 00             	pushw  $0x0
    813b:	67 66 8d 85 34 f4    	lea    -0xbcc(%di),%ax
    8141:	ff                   	(bad)  
    8142:	ff 66 50             	jmp    *0x50(%esi)
    8145:	66 e8 6d 09          	callw  8ab6 <_Z7memmovePvPKvm+0x4b>
    8149:	00 00                	add    %al,(%eax)
        read_prog_record();
    814b:	66 83 c4 0c          	add    $0xc,%sp
    814f:	66 53                	push   %bx
    8151:	66 e8 b3 19          	callw  9b08 <_ZN2sh4execERKNS_3cmdE+0x2dc>
    8155:	00 00                	add    %al,(%eax)
        sys_read_disk(0, (uint32_t)help, HELP_FILE_SECTOR, 1);
    8157:	67 66 c7 04 24 01    	movw   $0x124,(%si)
    815d:	00 00                	add    %al,(%eax)
    815f:	00 66 6a             	add    %ah,0x6a(%esi)
    8162:	40                   	inc    %eax
    8163:	67 66 8d 85 b4 fb    	lea    -0x44c(%di),%ax
    8169:	ff                   	(bad)  
    816a:	ff 66 50             	jmp    *0x50(%esi)
    816d:	66 6a 00             	pushw  $0x0
    8170:	66 e8 4d 03          	callw  84c1 <sys_get_scancode+0xf>
    8174:	00 00                	add    %al,(%eax)
    sh sh1;
    print_ok("Shell");
    8176:	66 83 c4 10          	add    $0x10,%sp
    817a:	66 b8 28 ba          	mov    $0xba28,%ax
    817e:	00 00                	add    %al,(%eax)
    8180:	66 e8 44 fe          	callw  7fc8 <interrupt_34h+0x5>
    8184:	ff                   	(bad)  
    8185:	ff 66 ff             	jmp    *-0x1(%esi)
    printf("%s\n", str);
    8188:	36 10 ba 66 68 10 bb 	adc    %bh,%ss:-0x44ef979a(%edx)
    818f:	00 00                	add    %al,(%eax)
    8191:	66 e8 a5 14          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    8195:	00 00                	add    %al,(%eax)
    sh1.run();
    8197:	66 58                	pop    %ax
    8199:	66 5a                	pop    %dx
    819b:	66 53                	push   %bx
    819d:	66 e8 a5 1a          	callw  9c46 <_ZN2sh16read_prog_recordEv+0x13c>
    81a1:	00 00                	add    %al,(%eax)
    81a3:	66 90                	xchg   %ax,%ax
    81a5:	66 90                	xchg   %ax,%ax
    81a7:	66 90                	xchg   %ax,%ax
    81a9:	66 90                	xchg   %ax,%ax
    81ab:	66 90                	xchg   %ax,%ax
    81ad:	66 90                	xchg   %ax,%ax
    81af:	90                   	nop

000081b0 <sys_bios_print_string>:
    81b0:	55                   	push   %ebp
    81b1:	89 e5                	mov    %esp,%ebp
    81b3:	8b 4e 0a             	mov    0xa(%esi),%ecx
    81b6:	8b 5e 0e             	mov    0xe(%esi),%ebx
    81b9:	b7 00                	mov    $0x0,%bh
    81bb:	8b 56 12             	mov    0x12(%esi),%edx
    81be:	8c d8                	mov    %ds,%eax
    81c0:	8e c0                	mov    %eax,%es
    81c2:	b8 01 13 8e ed       	mov    $0xed8e1301,%eax
    81c7:	8b 6e 06             	mov    0x6(%esi),%ebp
    81ca:	cd 10                	int    $0x10
    81cc:	8c ed                	mov    %gs,%ebp
    81ce:	5d                   	pop    %ebp
    81cf:	66 59                	pop    %cx
    81d1:	ff e1                	jmp    *%ecx

000081d3 <sys_bios_clear_screen>:
    81d3:	60                   	pusha  
    81d4:	b4 06                	mov    $0x6,%ah
    81d6:	b0 00                	mov    $0x0,%al
    81d8:	b7 07                	mov    $0x7,%bh
    81da:	b5 00                	mov    $0x0,%ch
    81dc:	b1 00                	mov    $0x0,%cl
    81de:	b6 18                	mov    $0x18,%dh
    81e0:	b2 4f                	mov    $0x4f,%dl
    81e2:	cd 10                	int    $0x10
    81e4:	61                   	popa   
    81e5:	66 59                	pop    %cx
    81e7:	ff e1                	jmp    *%ecx

000081e9 <sys_bios_getchar>:
    81e9:	b4 00                	mov    $0x0,%ah
    81eb:	cd 16                	int    $0x16
    81ed:	b4 00                	mov    $0x0,%ah
    81ef:	c3                   	ret    

000081f0 <sys_execve_bin>:
    81f0:	55                   	push   %ebp
    81f1:	89 e5                	mov    %esp,%ebp
    81f3:	60                   	pusha  
    81f4:	1e                   	push   %ds
    81f5:	06                   	push   %es
    81f6:	b8 00 10 8e d8       	mov    $0xd88e1000,%eax
    81fb:	8e c0                	mov    %eax,%es
    81fd:	8e d0                	mov    %eax,%ss
    81ff:	c7 06 00 a0 cd 00    	movl   $0xcda000,(%esi)
    8205:	c7 06 02 a0 20 00    	movl   $0x20a002,(%esi)
    820b:	c7 06 0a a0 1a 82    	movl   $0x821aa00a,(%esi)
    8211:	8c 0e                	mov    %cs,(%esi)
    8213:	0c a0                	or     $0xa0,%al
    8215:	ea                   	.byte 0xea
    8216:	00                   	.byte 0x0
    8217:	a1                   	.byte 0xa1
    8218:	00 10                	add    %dl,(%eax)

0000821a <return_point>:
    821a:	b8 00 00 8e d0       	mov    $0xd08e0000,%eax
    821f:	58                   	pop    %eax
    8220:	8e c0                	mov    %eax,%es
    8222:	58                   	pop    %eax
    8223:	8e d8                	mov    %eax,%ds
    8225:	61                   	popa   
    8226:	5d                   	pop    %ebp
    8227:	66 59                	pop    %cx
    8229:	ff e1                	jmp    *%ecx

0000822b <sys_sleep>:
    822b:	55                   	push   %ebp
    822c:	89 e5                	mov    %esp,%ebp
    822e:	60                   	pusha  
    822f:	8b 4e 0a             	mov    0xa(%esi),%ecx

00008232 <sleep_loop>:
    8232:	80 3e 8c             	cmpb   $0x8c,(%esi)
    8235:	7e 00                	jle    8237 <sleep_loop+0x5>
    8237:	74 f9                	je     8232 <sleep_loop>
    8239:	b8 00 00 86 06       	mov    $0x6860000,%eax
    823e:	8c 7e e2             	mov    %?,-0x1e(%esi)
    8241:	f0 61                	lock popa 
    8243:	5d                   	pop    %ebp
    8244:	66 59                	pop    %cx
    8246:	ff e1                	jmp    *%ecx

00008248 <sys_bios_print_int>:
#include "sys_lib.h"
void sys_bios_print_int(int num, int color, int pos)
{
    8248:	66 55                	push   %bp
    824a:	66 89 e5             	mov    %sp,%bp
    824d:	66 57                	push   %di
    824f:	66 56                	push   %si
    8251:	66 53                	push   %bx
    8253:	66 50                	push   %ax
    int num_ = num;
    8255:	67 66 8b 45 08       	mov    0x8(%di),%ax
    int len = 1;
    825a:	66 b9 01 00          	mov    $0x1,%cx
    825e:	00 00                	add    %al,(%eax)
    while(num_ /= 10) len++;
    8260:	66 bb 0a 00          	mov    $0xa,%bx
    8264:	00 00                	add    %al,(%eax)
    8266:	66 99                	cwtd   
    8268:	66 f7 fb             	idiv   %bx
    826b:	66 85 c0             	test   %ax,%ax
    826e:	74 04                	je     8274 <sys_bios_print_int+0x2c>
    8270:	66 41                	inc    %cx
    8272:	eb f2                	jmp    8266 <sys_bios_print_int+0x1e>
    char arr[len + 1];
    8274:	67 66 8d 41 04       	lea    0x4(%bx,%di),%ax
    8279:	66 83 e0 fc          	and    $0xfffc,%ax
    827d:	66 29 c4             	sub    %ax,%sp
    8280:	66 89 e7             	mov    %sp,%di
    8283:	67 66 8d 1c          	lea    (%si),%bx
    8287:	0c 67                	or     $0x67,%al
    int power = 1;
    8289:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
    828f:	00 00                	add    %al,(%eax)
    for(int i = 0; i < len; ++i, power *= 10)
        arr[len - i - 1] = '0' + ((num / power) % 10);
    8291:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8296:	66 99                	cwtd   
    8298:	67 66 f7 7d f0       	idivw  -0x10(%di)
    829d:	66 be 0a 00          	mov    $0xa,%si
    82a1:	00 00                	add    %al,(%eax)
    82a3:	66 99                	cwtd   
    82a5:	66 f7 fe             	idiv   %si
    82a8:	66 83 c2 30          	add    $0x30,%dx
    82ac:	67 88 53 ff          	mov    %dl,-0x1(%bp,%di)
    for(int i = 0; i < len; ++i, power *= 10)
    82b0:	67 66 6b 45 f0 0a    	imul   $0xa,-0x10(%di),%ax
    82b6:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
    82bb:	66 4b                	dec    %bx
    82bd:	66 39 df             	cmp    %bx,%di
    82c0:	75 cf                	jne    8291 <sys_bios_print_int+0x49>
    arr[len] = '\0';
    82c2:	67 c6 04 0f          	movb   $0xf,(%si)
    82c6:	00 67 66             	add    %ah,0x66(%edi)
    sys_bios_print_string(arr, len, color, pos);
    82c9:	ff 75 10             	pushl  0x10(%ebp)
    82cc:	67 66 ff 75 0c       	pushw  0xc(%di)
    82d1:	66 51                	push   %cx
    82d3:	66 57                	push   %di
    82d5:	66 e8 d5 fe          	callw  81ae <kernel_main+0xfb>
    82d9:	ff                   	(bad)  
    82da:	ff 66 83             	jmp    *-0x7d(%esi)
}
    82dd:	c4 10                	les    (%eax),%edx
    82df:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    82e4:	66 5b                	pop    %bx
    82e6:	66 5e                	pop    %si
    82e8:	66 5f                	pop    %di
    82ea:	66 5d                	pop    %bp
    82ec:	66 c3                	retw   

000082ee <sys_putchar>:
    //"mov word ptr gs:[bp],ax\n\t"
                   //".att_syntax noprefix\n\t");
//}

void sys_putchar(int c, int color, int x, int y)
{
    82ee:	66 55                	push   %bp
    82f0:	66 89 e5             	mov    %sp,%bp
    82f3:	66 53                	push   %bx
    int offset = (x * 80 + y)*2;
    uint16_t ch = c | (color << 8);
    82f5:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    82fa:	66 c1 e0 08          	shl    $0x8,%ax
    82fe:	67 66 0b 45 08       	or     0x8(%di),%ax
    int offset = (x * 80 + y)*2;
    8303:	67 66 6b 5d 10 50    	imul   $0x50,0x10(%di),%bx
    8309:	67 66 03 5d 14       	add    0x14(%di),%bx
    830e:	66 01 db             	add    %bx,%bx
    "mov word ptr gs:[bp],ax\n\t"
    "popa\n\t"
    ".att_syntax noprefix\n\t"
    :
    :"a"(ch),"b"(offset)
    :"%ecx");
    8311:	66 60                	pushaw 
    8313:	b9 00 b8 8e e9       	mov    $0xe98eb800,%ecx
    8318:	89 dd                	mov    %ebx,%ebp
    831a:	65 89 46 00          	mov    %eax,%gs:0x0(%esi)
    831e:	66 61                	popaw  
}
    8320:	66 5b                	pop    %bx
    8322:	66 5d                	pop    %bp
    8324:	66 c3                	retw   

00008326 <sys_print_string>:
{
    8326:	66 55                	push   %bp
    8328:	66 89 e5             	mov    %sp,%bp
    832b:	66 56                	push   %si
    832d:	66 53                	push   %bx
    832f:	67 66 8b 5d 14       	mov    0x14(%di),%bx
    8334:	67 66 8b 75 0c       	mov    0xc(%di),%si
    8339:	66 01 de             	add    %bx,%si
    833c:	66 89 da             	mov    %bx,%dx
    for(unsigned int i = 0; i < len; ++i)
    833f:	66 39 f2             	cmp    %si,%dx
    8342:	74 28                	je     836c <sys_print_string+0x46>
        sys_putchar(str[i], color, x, y + i);
    8344:	66 52                	push   %dx
    8346:	67 66 ff 75 10       	pushw  0x10(%di)
    834b:	66 6a 07             	pushw  $0x7
    834e:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8353:	66 29 d8             	sub    %bx,%ax
    8356:	67 66 0f be 04       	movsbw (%si),%ax
    835b:	10 66 50             	adc    %ah,0x50(%esi)
    835e:	66 e8 8a ff          	callw  82ec <sys_bios_print_int+0xa4>
    8362:	ff                   	(bad)  
    8363:	ff 66 42             	jmp    *0x42(%esi)
    for(unsigned int i = 0; i < len; ++i)
    8366:	66 83 c4 10          	add    $0x10,%sp
    836a:	eb d3                	jmp    833f <sys_print_string+0x19>
}
    836c:	67 66 8d 65 f8       	lea    -0x8(%di),%sp
    8371:	66 5b                	pop    %bx
    8373:	66 5e                	pop    %si
    8375:	66 5d                	pop    %bp
    8377:	66 c3                	retw   

00008379 <sys_print_int>:
{
    8379:	66 55                	push   %bp
    837b:	66 89 e5             	mov    %sp,%bp
    837e:	66 57                	push   %di
    8380:	66 56                	push   %si
    8382:	66 53                	push   %bx
    8384:	66 50                	push   %ax
    int num_ = num;
    8386:	67 66 8b 45 08       	mov    0x8(%di),%ax
    int len = 1;
    838b:	66 b9 01 00          	mov    $0x1,%cx
    838f:	00 00                	add    %al,(%eax)
    while(num_ /= 10) len++;
    8391:	66 bb 0a 00          	mov    $0xa,%bx
    8395:	00 00                	add    %al,(%eax)
    8397:	66 99                	cwtd   
    8399:	66 f7 fb             	idiv   %bx
    839c:	66 85 c0             	test   %ax,%ax
    839f:	74 04                	je     83a5 <sys_print_int+0x2c>
    83a1:	66 41                	inc    %cx
    83a3:	eb f2                	jmp    8397 <sys_print_int+0x1e>
    char arr[len + 1];
    83a5:	67 66 8d 41 04       	lea    0x4(%bx,%di),%ax
    83aa:	66 83 e0 fc          	and    $0xfffc,%ax
    83ae:	66 29 c4             	sub    %ax,%sp
    83b1:	66 89 e7             	mov    %sp,%di
    83b4:	67 66 8d 1c          	lea    (%si),%bx
    83b8:	0c 67                	or     $0x67,%al
    int power = 1;
    83ba:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
    83c0:	00 00                	add    %al,(%eax)
        arr[len - i - 1] = '0' + ((num / power) % 10);
    83c2:	67 66 8b 45 08       	mov    0x8(%di),%ax
    83c7:	66 99                	cwtd   
    83c9:	67 66 f7 7d f0       	idivw  -0x10(%di)
    83ce:	66 be 0a 00          	mov    $0xa,%si
    83d2:	00 00                	add    %al,(%eax)
    83d4:	66 99                	cwtd   
    83d6:	66 f7 fe             	idiv   %si
    83d9:	66 83 c2 30          	add    $0x30,%dx
    83dd:	67 88 53 ff          	mov    %dl,-0x1(%bp,%di)
    for(int i = 0; i < len; ++i, power *= 10)
    83e1:	67 66 6b 45 f0 0a    	imul   $0xa,-0x10(%di),%ax
    83e7:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
    83ec:	66 4b                	dec    %bx
    83ee:	66 39 df             	cmp    %bx,%di
    83f1:	75 cf                	jne    83c2 <sys_print_int+0x49>
    arr[len] = '\0';
    83f3:	67 c6 04 0f          	movb   $0xf,(%si)
    83f7:	00 67 66             	add    %ah,0x66(%edi)
    sys_print_string(arr, len, x, y); 
    83fa:	ff 75 10             	pushl  0x10(%ebp)
    83fd:	67 66 ff 75 0c       	pushw  0xc(%di)
    8402:	66 51                	push   %cx
    8404:	66 57                	push   %di
    8406:	66 e8 1a ff          	callw  8324 <sys_putchar+0x36>
    840a:	ff                   	(bad)  
    840b:	ff 66 83             	jmp    *-0x7d(%esi)
}
    840e:	c4 10                	les    (%eax),%edx
    8410:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    8415:	66 5b                	pop    %bx
    8417:	66 5e                	pop    %si
    8419:	66 5f                	pop    %di
    841b:	66 5d                	pop    %bp
    841d:	66 c3                	retw   

0000841f <sys_bios_scroll_up>:

void sys_bios_scroll_up(int color)
{
    841f:	66 55                	push   %bp
    8421:	66 89 e5             	mov    %sp,%bp
    "movb $79, %%dl\n\t"
    "movb $0x06, %%ah\n\t"
    "int $0x10\n\t"
    "popa\n\t"
    :
    : "g"(color));
    8424:	66 60                	pushaw 
    8426:	b0 01                	mov    $0x1,%al
    8428:	67 8a 7d 08          	mov    0x8(%di),%bh
    842c:	b5 00                	mov    $0x0,%ch
    842e:	b1 00                	mov    $0x0,%cl
    8430:	b6 18                	mov    $0x18,%dh
    8432:	b2 4f                	mov    $0x4f,%dl
    8434:	b4 06                	mov    $0x6,%ah
    8436:	cd 10                	int    $0x10
    8438:	66 61                	popaw  
}
    843a:	66 5d                	pop    %bp
    843c:	66 c3                	retw   

0000843e <sys_bios_putchar>:

void sys_bios_putchar(char c, int color, int x, int y)
{
    843e:	66 55                	push   %bp
    8440:	66 89 e5             	mov    %sp,%bp
    8443:	66 50                	push   %ax
    8445:	67 66 8b 45 08       	mov    0x8(%di),%ax
    844a:	67 88 45 fc          	mov    %al,-0x4(%di)
    sys_bios_print_string(&c, 1, color, MAKE_POS(x, y));
    844e:	67 66 8b 45 10       	mov    0x10(%di),%ax
    8453:	66 c1 e0 08          	shl    $0x8,%ax
    8457:	67 66 0f b6 55 14    	movzbw 0x14(%di),%dx
    845d:	66 09 d0             	or     %dx,%ax
    8460:	66 50                	push   %ax
    8462:	67 66 ff 75 0c       	pushw  0xc(%di)
    8467:	66 6a 01             	pushw  $0x1
    846a:	67 66 8d 45 fc       	lea    -0x4(%di),%ax
    846f:	66 50                	push   %ax
    8471:	66 e8 39 fd          	callw  81ae <kernel_main+0xfb>
    8475:	ff                   	(bad)  
    8476:	ff 66 83             	jmp    *-0x7d(%esi)
}
    8479:	c4 10                	les    (%eax),%edx
    847b:	66 c9                	leavew 
    847d:	66 c3                	retw   

0000847f <sys_inb>:

uint8_t sys_inb(uint16_t port)
{
    847f:	66 55                	push   %bp
    8481:	66 89 e5             	mov    %sp,%bp
    uint8_t ret;
    asm volatile ( "inb %1, %0"
                   : "=a"(ret)
                   : "Nd"(port) );
    8484:	67 66 8b 55 08       	mov    0x8(%di),%dx
    8489:	ec                   	in     (%dx),%al
    return ret;
}
    848a:	66 5d                	pop    %bp
    848c:	66 c3                	retw   

0000848e <sys_outb>:
//    asm(".att_syntax noprefix\n");
//    return ret;
//}

void sys_outb(uint16_t port, uint8_t data)
{
    848e:	66 55                	push   %bp
    8490:	66 89 e5             	mov    %sp,%bp
    asm volatile ( "outb %0, %1"
                   : 
                   : "a"(data), "Nd"(port) );
    8493:	67 66 8b 55 08       	mov    0x8(%di),%dx
    8498:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    849d:	ee                   	out    %al,(%dx)
}
    849e:	66 5d                	pop    %bp
    84a0:	66 c3                	retw   

000084a2 <sys_dbg_bochs_putc>:
//                    : "=a"(ret)
//                    : "Nd"(port) );
//     return ret;
// }

void sys_dbg_bochs_putc(char c){
    84a2:	66 55                	push   %bp
    84a4:	66 89 e5             	mov    %sp,%bp
                   : "a"(data), "Nd"(port) );
    84a7:	67 66 8b 45 08       	mov    0x8(%di),%ax
    84ac:	e6 e9                	out    %al,$0xe9
    sys_outb(0xe9, (uint8_t)c);
}
    84ae:	66 5d                	pop    %bp
    84b0:	66 c3                	retw   

000084b2 <sys_get_scancode>:

char sys_get_scancode()
{
    84b2:	66 55                	push   %bp
    84b4:	66 89 e5             	mov    %sp,%bp
                   : "Nd"(port) );
    84b7:	e4 64                	in     $0x64,%al
    while (!(sys_inb(0x64) & 1));
    84b9:	a8 01                	test   $0x1,%al
    84bb:	74 fa                	je     84b7 <sys_get_scancode+0x5>
                   : "Nd"(port) );
    84bd:	e4 60                	in     $0x60,%al
    return sys_inb(0x60);
}
    84bf:	66 5d                	pop    %bp
    84c1:	66 c3                	retw   

000084c3 <sys_read_disk>:

void sys_read_disk(uint32_t segment, uint32_t address, uint16_t logical_start_sector, uint8_t secotr_cnt)
{
    84c3:	66 55                	push   %bp
    84c5:	66 89 e5             	mov    %sp,%bp
    84c8:	66 53                	push   %bx
    uint8_t head = (logical_start_sector % (FLOPPY_HEAD_PER_DISK * FLOPPY_SECTOR_PER_TRACK)) / FLOPPY_SECTOR_PER_TRACK;
    84ca:	67 66 0f b7 45 10    	movzww 0x10(%di),%ax
    84d0:	66 b9 24 00          	mov    $0x24,%cx
    84d4:	00 00                	add    %al,(%eax)
    84d6:	66 99                	cwtd   
    84d8:	66 f7 f9             	idiv   %cx
    84db:	66 89 c1             	mov    %ax,%cx
    84de:	66 bb 12 00          	mov    $0x12,%bx
    84e2:	00 00                	add    %al,(%eax)
    84e4:	66 89 d0             	mov    %dx,%ax
    84e7:	66 99                	cwtd   
    84e9:	66 f7 fb             	idiv   %bx
    uint16_t cylinder = logical_start_sector / (FLOPPY_HEAD_PER_DISK * FLOPPY_SECTOR_PER_TRACK);
    uint16_t sector = (logical_start_sector % (FLOPPY_HEAD_PER_DISK * FLOPPY_SECTOR_PER_TRACK)) % FLOPPY_SECTOR_PER_TRACK + 1;
    //位操作一定要注意类型匹配（两小时）
    uint16_t mask1 = 255;
    uint16_t mask2 = 768;
    uint16_t _cx = ((cylinder & mask1) << 8) | ((cylinder & mask2) >> 2) | sector;
    84ec:	66 89 cb             	mov    %cx,%bx
    84ef:	66 c1 e3 08          	shl    $0x8,%bx
    84f3:	66 81 e1 00 03       	and    $0x300,%cx
    84f8:	00 00                	add    %al,(%eax)
    84fa:	66 c1 f9 02          	sar    $0x2,%cx
    84fe:	66 09 d9             	or     %bx,%cx
    uint16_t sector = (logical_start_sector % (FLOPPY_HEAD_PER_DISK * FLOPPY_SECTOR_PER_TRACK)) % FLOPPY_SECTOR_PER_TRACK + 1;
    8501:	66 42                	inc    %dx
    uint16_t _cx = ((cylinder & mask1) << 8) | ((cylinder & mask2) >> 2) | sector;
    8503:	66 09 d1             	or     %dx,%cx
     "movb %4, %%al\n\t"    //扇区数
     "movb $0, %%dl\n\t"    //驱动器号
     "movb $2, %%ah\n\t"    //功能号
     "int $0x13\n\t"
     "pop %%es\n\t"
     : :"g"(segment), "g"(address), "g"(head), "g"(_cx), "g" (secotr_cnt));
    8506:	06                   	push   %es
    8507:	67 8b 5d 08          	mov    0x8(%di),%ebx
    850b:	8e c3                	mov    %ebx,%es
    850d:	67 8b 5d 0c          	mov    0xc(%di),%ebx
    8511:	88 c6                	mov    %al,%dh
    8513:	89 c9                	mov    %ecx,%ecx
    8515:	67 8a 45 14          	mov    0x14(%di),%al
    8519:	b2 00                	mov    $0x0,%dl
    851b:	b4 02                	mov    $0x2,%ah
    851d:	cd 13                	int    $0x13
    851f:	07                   	pop    %es
}
    8520:	66 5b                	pop    %bx
    8522:	66 5d                	pop    %bp
    8524:	66 c3                	retw   

00008526 <interrupt_33h_c>:

extern "C" void interrupt_33h_c() {
    8526:	66 55                	push   %bp
    8528:	66 89 e5             	mov    %sp,%bp
    const char* l12 = "|_   _|    | |   |____ ||____ |";
    const char* l13 = "  | | _ __ | |_      / /    / /";
    const char* l14 = "  | || '_ \\| __|     \\ \\    \\ \\";
    const char* l15 = " _| || | | | |_  .___/ /.___/ /";
    const char* l16 = " \\___/_| |_|\\__| \\____/ \\____/ ";
    sys_bios_print_string(l11, 31, MAKE_COLOR(VGA_BLACK, VGA_CYAN), MAKE_POS(0, 0));
    852b:	66 6a 00             	pushw  $0x0
    852e:	66 6a 03             	pushw  $0x3
    8531:	66 6a 1f             	pushw  $0x1f
    8534:	66 68 80 bb          	pushw  $0xbb80
    8538:	00 00                	add    %al,(%eax)
    853a:	66 e8 70 fc          	callw  81ae <kernel_main+0xfb>
    853e:	ff                   	(bad)  
    853f:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l12, 31, MAKE_COLOR(VGA_BLACK, VGA_CYAN), MAKE_POS(1, 0));
    8542:	c4 10                	les    (%eax),%edx
    8544:	66 68 00 01          	pushw  $0x100
    8548:	00 00                	add    %al,(%eax)
    854a:	66 6a 03             	pushw  $0x3
    854d:	66 6a 1f             	pushw  $0x1f
    8550:	66 68 a0 bb          	pushw  $0xbba0
    8554:	00 00                	add    %al,(%eax)
    8556:	66 e8 54 fc          	callw  81ae <kernel_main+0xfb>
    855a:	ff                   	(bad)  
    855b:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l13, 31, MAKE_COLOR(VGA_BLACK, VGA_CYAN), MAKE_POS(2, 0));
    855e:	c4 10                	les    (%eax),%edx
    8560:	66 68 00 02          	pushw  $0x200
    8564:	00 00                	add    %al,(%eax)
    8566:	66 6a 03             	pushw  $0x3
    8569:	66 6a 1f             	pushw  $0x1f
    856c:	66 68 c0 bb          	pushw  $0xbbc0
    8570:	00 00                	add    %al,(%eax)
    8572:	66 e8 38 fc          	callw  81ae <kernel_main+0xfb>
    8576:	ff                   	(bad)  
    8577:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l14, 31, MAKE_COLOR(VGA_BLACK, VGA_CYAN), MAKE_POS(3, 0));
    857a:	c4 10                	les    (%eax),%edx
    857c:	66 68 00 03          	pushw  $0x300
    8580:	00 00                	add    %al,(%eax)
    8582:	66 6a 03             	pushw  $0x3
    8585:	66 6a 1f             	pushw  $0x1f
    8588:	66 68 e0 bb          	pushw  $0xbbe0
    858c:	00 00                	add    %al,(%eax)
    858e:	66 e8 1c fc          	callw  81ae <kernel_main+0xfb>
    8592:	ff                   	(bad)  
    8593:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l15, 31, MAKE_COLOR(VGA_BLACK, VGA_CYAN), MAKE_POS(4, 0));
    8596:	c4 10                	les    (%eax),%edx
    8598:	66 68 00 04          	pushw  $0x400
    859c:	00 00                	add    %al,(%eax)
    859e:	66 6a 03             	pushw  $0x3
    85a1:	66 6a 1f             	pushw  $0x1f
    85a4:	66 68 00 bc          	pushw  $0xbc00
    85a8:	00 00                	add    %al,(%eax)
    85aa:	66 e8 00 fc          	callw  81ae <kernel_main+0xfb>
    85ae:	ff                   	(bad)  
    85af:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l16, 31, MAKE_COLOR(VGA_BLACK, VGA_CYAN), MAKE_POS(5, 0));
    85b2:	c4 10                	les    (%eax),%edx
    85b4:	66 68 00 05          	pushw  $0x500
    85b8:	00 00                	add    %al,(%eax)
    85ba:	66 6a 03             	pushw  $0x3
    85bd:	66 6a 1f             	pushw  $0x1f
    85c0:	66 68 20 bc          	pushw  $0xbc20
    85c4:	00 00                	add    %al,(%eax)
    85c6:	66 e8 e4 fb          	callw  81ae <kernel_main+0xfb>
    85ca:	ff                   	(bad)  
    85cb:	ff 66 83             	jmp    *-0x7d(%esi)
}
    85ce:	c4 10                	les    (%eax),%edx
    85d0:	66 c9                	leavew 
    85d2:	66 c3                	retw   

000085d4 <interrupt_34h_c>:

extern "C" void interrupt_34h_c() {
    85d4:	66 55                	push   %bp
    85d6:	66 89 e5             	mov    %sp,%bp
    const char * l16 = "| $$$$$$$$| $$$$$$$$| $$  | $$ _\\$$$$$$\\";
    const char * l17 = "| $$  | $$| $$  | $$| $$__/ $$|  \\__| $$";
    const char * l18 = "| $$  | $$| $$  | $$ \\$$    $$ \\$$    $$";
    const char * l19 = " \\$$   \\$$ \\$$   \\$$  \\$$$$$$   \\$$$$$$ ";

    sys_bios_print_string(l11, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(0, 40));
    85d9:	66 6a 28             	pushw  $0x28
    85dc:	66 6a 0b             	pushw  $0xb
    85df:	66 6a 28             	pushw  $0x28
    85e2:	66 68 40 bc          	pushw  $0xbc40
    85e6:	00 00                	add    %al,(%eax)
    85e8:	66 e8 c2 fb          	callw  81ae <kernel_main+0xfb>
    85ec:	ff                   	(bad)  
    85ed:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l12, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(1, 40));
    85f0:	c4 10                	les    (%eax),%edx
    85f2:	66 68 28 01          	pushw  $0x128
    85f6:	00 00                	add    %al,(%eax)
    85f8:	66 6a 0b             	pushw  $0xb
    85fb:	66 6a 28             	pushw  $0x28
    85fe:	66 68 69 bc          	pushw  $0xbc69
    8602:	00 00                	add    %al,(%eax)
    8604:	66 e8 a6 fb          	callw  81ae <kernel_main+0xfb>
    8608:	ff                   	(bad)  
    8609:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l13, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(2, 40));
    860c:	c4 10                	les    (%eax),%edx
    860e:	66 68 28 02          	pushw  $0x228
    8612:	00 00                	add    %al,(%eax)
    8614:	66 6a 0b             	pushw  $0xb
    8617:	66 6a 28             	pushw  $0x28
    861a:	66 68 92 bc          	pushw  $0xbc92
    861e:	00 00                	add    %al,(%eax)
    8620:	66 e8 8a fb          	callw  81ae <kernel_main+0xfb>
    8624:	ff                   	(bad)  
    8625:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l14, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(3, 40));
    8628:	c4 10                	les    (%eax),%edx
    862a:	66 68 28 03          	pushw  $0x328
    862e:	00 00                	add    %al,(%eax)
    8630:	66 6a 0b             	pushw  $0xb
    8633:	66 6a 28             	pushw  $0x28
    8636:	66 68 bb bc          	pushw  $0xbcbb
    863a:	00 00                	add    %al,(%eax)
    863c:	66 e8 6e fb          	callw  81ae <kernel_main+0xfb>
    8640:	ff                   	(bad)  
    8641:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l15, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(4, 40));
    8644:	c4 10                	les    (%eax),%edx
    8646:	66 68 28 04          	pushw  $0x428
    864a:	00 00                	add    %al,(%eax)
    864c:	66 6a 0b             	pushw  $0xb
    864f:	66 6a 28             	pushw  $0x28
    8652:	66 68 e4 bc          	pushw  $0xbce4
    8656:	00 00                	add    %al,(%eax)
    8658:	66 e8 52 fb          	callw  81ae <kernel_main+0xfb>
    865c:	ff                   	(bad)  
    865d:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l16, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(5, 40));
    8660:	c4 10                	les    (%eax),%edx
    8662:	66 68 28 05          	pushw  $0x528
    8666:	00 00                	add    %al,(%eax)
    8668:	66 6a 0b             	pushw  $0xb
    866b:	66 6a 28             	pushw  $0x28
    866e:	66 68 0d bd          	pushw  $0xbd0d
    8672:	00 00                	add    %al,(%eax)
    8674:	66 e8 36 fb          	callw  81ae <kernel_main+0xfb>
    8678:	ff                   	(bad)  
    8679:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l17, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(6, 40));
    867c:	c4 10                	les    (%eax),%edx
    867e:	66 68 28 06          	pushw  $0x628
    8682:	00 00                	add    %al,(%eax)
    8684:	66 6a 0b             	pushw  $0xb
    8687:	66 6a 28             	pushw  $0x28
    868a:	66 68 36 bd          	pushw  $0xbd36
    868e:	00 00                	add    %al,(%eax)
    8690:	66 e8 1a fb          	callw  81ae <kernel_main+0xfb>
    8694:	ff                   	(bad)  
    8695:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l18, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(7, 40));
    8698:	c4 10                	les    (%eax),%edx
    869a:	66 68 28 07          	pushw  $0x728
    869e:	00 00                	add    %al,(%eax)
    86a0:	66 6a 0b             	pushw  $0xb
    86a3:	66 6a 28             	pushw  $0x28
    86a6:	66 68 5f bd          	pushw  $0xbd5f
    86aa:	00 00                	add    %al,(%eax)
    86ac:	66 e8 fe fa          	callw  81ae <kernel_main+0xfb>
    86b0:	ff                   	(bad)  
    86b1:	ff 66 83             	jmp    *-0x7d(%esi)
    sys_bios_print_string(l19, 40, MAKE_COLOR(VGA_BLACK, VGA_BRIGHT_CYAN), MAKE_POS(8, 40));
    86b4:	c4 10                	les    (%eax),%edx
    86b6:	66 68 28 08          	pushw  $0x828
    86ba:	00 00                	add    %al,(%eax)
    86bc:	66 6a 0b             	pushw  $0xb
    86bf:	66 6a 28             	pushw  $0x28
    86c2:	66 68 88 bd          	pushw  $0xbd88
    86c6:	00 00                	add    %al,(%eax)
    86c8:	66 e8 e2 fa          	callw  81ae <kernel_main+0xfb>
    86cc:	ff                   	(bad)  
    86cd:	ff 66 83             	jmp    *-0x7d(%esi)
}
    86d0:	c4 10                	les    (%eax),%edx
    86d2:	66 c9                	leavew 
    86d4:	66 c3                	retw   

000086d6 <_Z9read_cmosPh>:
#include "sys_lib.h"
#include "../libc/stdio.h"
void read_cmos (unsigned char array [])
{
    86d6:	66 55                	push   %bp
    86d8:	66 89 e5             	mov    %sp,%bp
    86db:	66 53                	push   %bx
    86dd:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    86e2:	66 31 d2             	xor    %dx,%dx
   unsigned char tvalue, index;
 
   for(index = 0; index < 128; index++)
    86e5:	66 81 fa 80 00       	cmp    $0x80,%dx
    86ea:	00 00                	add    %al,(%eax)
    86ec:	74 12                	je     8700 <_Z9read_cmosPh+0x2a>
            "sti\n\t"
            "movb %%al, %0\n\t"
            :"=r"(tvalue)
            :"r"(index)
            :"%eax"
               );
    86ee:	fa                   	cli    
    86ef:	88 d0                	mov    %dl,%al
    86f1:	e6 70                	out    %al,$0x70
    86f3:	e4 71                	in     $0x71,%al
    86f5:	fb                   	sti    
    86f6:	88 c3                	mov    %al,%bl
       array[index] = tvalue;
    86f8:	67 88 1c             	mov    %bl,(%si)
    86fb:	11 66 42             	adc    %esp,0x42(%esi)
   for(index = 0; index < 128; index++)
    86fe:	eb e5                	jmp    86e5 <_Z9read_cmosPh+0xf>
   }
}
    8700:	66 5b                	pop    %bx
    8702:	66 5d                	pop    %bp
    8704:	66 c3                	retw   

00008706 <_Z27get_update_in_progress_flagv>:
enum {
      cmos_address = 0x70,
      cmos_data    = 0x71
};
 
int get_update_in_progress_flag() {
    8706:	66 55                	push   %bp
    8708:	66 89 e5             	mov    %sp,%bp
      sys_outb(cmos_address, 0x0A);
    870b:	66 6a 0a             	pushw  $0xa
    870e:	66 6a 70             	pushw  $0x70
    8711:	66 e8 77 fd          	callw  848c <sys_inb+0xd>
    8715:	ff                   	(bad)  
    8716:	ff 66 58             	jmp    *0x58(%esi)
      return (sys_inb(cmos_data) & 0x80);
    8719:	66 5a                	pop    %dx
    871b:	66 6a 71             	pushw  $0x71
    871e:	66 e8 5b fd          	callw  847d <sys_bios_putchar+0x3f>
    8722:	ff                   	(bad)  
    8723:	ff 66 83             	jmp    *-0x7d(%esi)
    8726:	e0 80                	loopne 86a8 <interrupt_34h_c+0xd4>
    8728:	66 0f b6 c0          	movzbw %al,%ax
}
    872c:	66 c9                	leavew 
    872e:	66 c3                	retw   

00008730 <_Z16get_RTC_registeri>:
 
unsigned char get_RTC_register(int reg) {
    8730:	66 55                	push   %bp
    8732:	66 89 e5             	mov    %sp,%bp
      sys_outb(cmos_address, reg);
    8735:	67 66 0f b6 45 08    	movzbw 0x8(%di),%ax
    873b:	66 50                	push   %ax
    873d:	66 6a 70             	pushw  $0x70
    8740:	66 e8 48 fd          	callw  848c <sys_inb+0xd>
    8744:	ff                   	(bad)  
    8745:	ff 66 58             	jmp    *0x58(%esi)
      return sys_inb(cmos_data);
    8748:	66 5a                	pop    %dx
    874a:	67 66 c7 45 08 71 00 	movw   $0x71,0x8(%di)
    8751:	00 00                	add    %al,(%eax)
}
    8753:	66 c9                	leavew 
      return sys_inb(cmos_data);
    8755:	e9                   	.byte 0xe9
    8756:	27                   	daa    
    8757:	fd                   	std    

00008758 <read_rtc>:
 
void read_rtc() {
    8758:	66 55                	push   %bp
    875a:	66 89 e5             	mov    %sp,%bp
    875d:	66 57                	push   %di
    875f:	66 56                	push   %si
    8761:	66 53                	push   %bx
    8763:	66 53                	push   %bx
      unsigned char last_day;
      unsigned char last_month;
      unsigned char last_year;
      unsigned char registerB;
 
      while (get_update_in_progress_flag());
    8765:	66 e8 9b ff          	callw  8704 <_Z9read_cmosPh+0x2e>
    8769:	ff                   	(bad)  
    876a:	ff 66 85             	jmp    *-0x7b(%esi)
    876d:	c0 75 f5 66          	shlb   $0x66,-0xb(%ebp)
      sys_internal_second = get_RTC_register(0x00);
    8771:	6a 00                	push   $0x0
    8773:	66 e8 b7 ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    8777:	ff                   	(bad)  
    8778:	ff a2 40 aa 67 66    	jmp    *0x6667aa40(%edx)
      sys_internal_minute = get_RTC_register(0x02);
    877e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    8785:	66 e8 a5 ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    8789:	ff                   	(bad)  
    878a:	ff a2 3f aa 67 66    	jmp    *0x6667aa3f(%edx)
      sys_internal_hour = get_RTC_register(0x04);
    8790:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    8797:	66 e8 93 ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    879b:	ff                   	(bad)  
    879c:	ff a2 3e aa 67 66    	jmp    *0x6667aa3e(%edx)
      sys_internal_day = get_RTC_register(0x07);
    87a2:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
    87a9:	66 e8 81 ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    87ad:	ff                   	(bad)  
    87ae:	ff a2 3d aa 67 66    	jmp    *0x6667aa3d(%edx)
      sys_internal_month = get_RTC_register(0x08);
    87b4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    87bb:	66 e8 6f ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    87bf:	ff                   	(bad)  
    87c0:	ff a2 3c aa 67 66    	jmp    *0x6667aa3c(%edx)
      sys_internal_year = get_RTC_register(0x09);
    87c6:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
    87cd:	66 e8 5d ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    87d1:	ff                   	(bad)  
    87d2:	ff 66 0f             	jmp    *0xf(%esi)
    87d5:	b6 c0                	mov    $0xc0,%dh
    87d7:	66 a3 38 aa 66 59    	mov    %ax,0x5966aa38
 
      do {
            last_second = sys_internal_second;
    87dd:	a0 40 aa 66 89       	mov    0x8966aa40,%al
    87e2:	c7                   	(bad)  
            last_minute = sys_internal_minute;
    87e3:	a0 3f aa 67 88       	mov    0x8867aa3f,%al
    87e8:	45                   	inc    %ebp
    87e9:	f3 8a 1e             	repz mov (%esi),%bl
            last_hour = sys_internal_hour;
    87ec:	3e aa                	ds stos %al,%es:(%edi)
            last_day = sys_internal_day;
    87ee:	a0 3d aa 67 88       	mov    0x8867aa3d,%al
    87f3:	45                   	inc    %ebp
    87f4:	f2 a0 3c aa 67 88    	repnz mov 0x8867aa3c,%al
            last_month = sys_internal_month;
    87fa:	45                   	inc    %ebp
    87fb:	f1                   	icebp  
            last_year = sys_internal_year;
    87fc:	66 8b 36             	mov    (%esi),%si
    87ff:	38 aa 66 e8 ff fe    	cmp    %ch,-0x100179a(%edx)
 
            while (get_update_in_progress_flag());           // Make sure an update isn't in progress
    8805:	ff                   	(bad)  
    8806:	ff 66 85             	jmp    *-0x7b(%esi)
    8809:	c0 75 f5 66          	shlb   $0x66,-0xb(%ebp)
            sys_internal_second = get_RTC_register(0x00);
    880d:	6a 00                	push   $0x0
    880f:	66 e8 1b ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    8813:	ff                   	(bad)  
    8814:	ff a2 40 aa 67 66    	jmp    *0x6667aa40(%edx)
            sys_internal_minute = get_RTC_register(0x02);
    881a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    8821:	66 e8 09 ff          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    8825:	ff                   	(bad)  
    8826:	ff a2 3f aa 67 66    	jmp    *0x6667aa3f(%edx)
            sys_internal_hour = get_RTC_register(0x04);
    882c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    8833:	66 e8 f7 fe          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    8837:	ff                   	(bad)  
    8838:	ff a2 3e aa 67 66    	jmp    *0x6667aa3e(%edx)
            sys_internal_day = get_RTC_register(0x07);
    883e:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
    8845:	66 e8 e5 fe          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    8849:	ff                   	(bad)  
    884a:	ff a2 3d aa 67 66    	jmp    *0x6667aa3d(%edx)
            sys_internal_month = get_RTC_register(0x08);
    8850:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    8857:	66 e8 d3 fe          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    885b:	ff                   	(bad)  
    885c:	ff a2 3c aa 67 66    	jmp    *0x6667aa3c(%edx)
            sys_internal_year = get_RTC_register(0x09);
    8862:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
    8869:	66 e8 c1 fe          	callw  872e <_Z27get_update_in_progress_flagv+0x28>
    886d:	ff                   	(bad)  
    886e:	ff 66 0f             	jmp    *0xf(%esi)
    8871:	b6 c0                	mov    $0xc0,%dh
    8873:	66 a3 38 aa 66 5a    	mov    %ax,0x5a66aa38
      } while( (last_second != sys_internal_second) || (last_minute != sys_internal_minute) || (last_hour != sys_internal_hour) ||
               (last_day != sys_internal_day) || (last_month != sys_internal_month) || (last_year != sys_internal_year));
    8879:	66 89 f9             	mov    %di,%cx
    887c:	38 0e                	cmp    %cl,(%esi)
    887e:	40                   	inc    %eax
    887f:	aa                   	stos   %al,%es:(%edi)
    8880:	0f 85 59 ff 67 8a    	jne    8a6887df <_GLOBAL_OFFSET_TABLE_+0x8a67c9f7>
      } while( (last_second != sys_internal_second) || (last_minute != sys_internal_minute) || (last_hour != sys_internal_hour) ||
    8886:	4d                   	dec    %ebp
    8887:	f3 38 0e             	repz cmp %cl,(%esi)
    888a:	3f                   	aas    
    888b:	aa                   	stos   %al,%es:(%edi)
    888c:	0f 85 4d ff 3a 1e    	jne    1e3b87df <_GLOBAL_OFFSET_TABLE_+0x1e3ac9f7>
    8892:	3e aa                	ds stos %al,%es:(%edi)
    8894:	0f 85 45 ff 67 8a    	jne    8a6887df <_GLOBAL_OFFSET_TABLE_+0x8a67c9f7>
    889a:	5d                   	pop    %ebp
    889b:	f2 3a 1e             	repnz cmp (%esi),%bl
    889e:	3d aa 0f 85 39       	cmp    $0x39850faa,%eax
    88a3:	ff 67 8a             	jmp    *-0x76(%edi)
               (last_day != sys_internal_day) || (last_month != sys_internal_month) || (last_year != sys_internal_year));
    88a6:	5d                   	pop    %ebp
    88a7:	f1                   	icebp  
    88a8:	3a 1e                	cmp    (%esi),%bl
    88aa:	3c aa                	cmp    $0xaa,%al
    88ac:	0f 85 2d ff 66 89    	jne    896787df <_GLOBAL_OFFSET_TABLE_+0x8966c9f7>
    88b2:	f1                   	icebp  
    88b3:	66 0f b6 f1          	movzbw %cl,%si
    88b7:	66 39 c6             	cmp    %ax,%si
    88ba:	0f 85 1f ff 66 6a    	jne    6a6787df <_GLOBAL_OFFSET_TABLE_+0x6a66c9f7>
 
      registerB = get_RTC_register(0x0B);
    88c0:	0b 66 e8             	or     -0x18(%esi),%esp
    88c3:	69 fe ff ff 66 89    	imul   $0x8966ffff,%esi,%edi
    88c9:	c6                   	(bad)  
 
      if (!(registerB & 0x04)) {
    88ca:	66 58                	pop    %ax
    88cc:	66 f7 c6 04 00       	test   $0x4,%si
    88d1:	00 00                	add    %al,(%eax)
    88d3:	0f 85 93 00 8a 16    	jne    168a896c <_GLOBAL_OFFSET_TABLE_+0x1689cb84>
            sys_internal_second = (sys_internal_second & 0x0F) + ((sys_internal_second / 16) * 10);
    88d9:	40                   	inc    %eax
    88da:	aa                   	stos   %al,%es:(%edi)
    88db:	88 d0                	mov    %dl,%al
    88dd:	c0 e8 04             	shr    $0x4,%al
    88e0:	b1 0a                	mov    $0xa,%cl
    88e2:	f6 e1                	mul    %cl
    88e4:	66 83 e2 0f          	and    $0xf,%dx
    88e8:	66 01 d0             	add    %dx,%ax
    88eb:	a2 40 aa 8a 16       	mov    %al,0x168aaa40
            sys_internal_minute = (sys_internal_minute & 0x0F) + ((sys_internal_minute / 16) * 10);
    88f0:	3f                   	aas    
    88f1:	aa                   	stos   %al,%es:(%edi)
    88f2:	88 d0                	mov    %dl,%al
    88f4:	c0 e8 04             	shr    $0x4,%al
    88f7:	f6 e1                	mul    %cl
    88f9:	66 83 e2 0f          	and    $0xf,%dx
    88fd:	66 01 d0             	add    %dx,%ax
    8900:	a2 3f aa 8a 1e       	mov    %al,0x1e8aaa3f
            sys_internal_hour = ( (sys_internal_hour & 0x0F) + (((sys_internal_hour & 0x70) / 16) * 10) ) | (sys_internal_hour & 0x80);
    8905:	3e aa                	ds stos %al,%es:(%edi)
    8907:	88 d8                	mov    %bl,%al
    8909:	c0 e8 04             	shr    $0x4,%al
    890c:	66 83 e0 07          	and    $0x7,%ax
    8910:	f6 e1                	mul    %cl
    8912:	88 da                	mov    %bl,%dl
    8914:	66 83 e2 0f          	and    $0xf,%dx
    8918:	66 01 c2             	add    %ax,%dx
    891b:	66 83 e3 80          	and    $0xff80,%bx
    891f:	66 09 da             	or     %bx,%dx
    8922:	88 16                	mov    %dl,(%esi)
    8924:	3e aa                	ds stos %al,%es:(%edi)
            sys_internal_day = (sys_internal_day & 0x0F) + ((sys_internal_day / 16) * 10);
    8926:	8a 16                	mov    (%esi),%dl
    8928:	3d aa 88 d0 c0       	cmp    $0xc0d088aa,%eax
    892d:	e8 04 f6 e1 66       	call   66e27f36 <_GLOBAL_OFFSET_TABLE_+0x66e1c14e>
    8932:	83 e2 0f             	and    $0xf,%edx
    8935:	66 01 d0             	add    %dx,%ax
    8938:	a2 3d aa 8a 16       	mov    %al,0x168aaa3d
            sys_internal_month = (sys_internal_month & 0x0F) + ((sys_internal_month / 16) * 10);
    893d:	3c aa                	cmp    $0xaa,%al
    893f:	88 d0                	mov    %dl,%al
    8941:	c0 e8 04             	shr    $0x4,%al
    8944:	f6 e1                	mul    %cl
    8946:	66 83 e2 0f          	and    $0xf,%dx
    894a:	66 01 d0             	add    %dx,%ax
    894d:	a2 3c aa 66 a1       	mov    %al,0xa166aa3c
            sys_internal_year = (sys_internal_year & 0x0F) + ((sys_internal_year / 16) * 10);
    8952:	38 aa 66 89 c2 66    	cmp    %ch,0x66c28966(%edx)
    8958:	c1 ea 04             	shr    $0x4,%edx
    895b:	66 6b d2 0a          	imul   $0xa,%dx,%dx
    895f:	66 83 e0 0f          	and    $0xf,%ax
    8963:	66 01 d0             	add    %dx,%ax
    8966:	66 a3 38 aa a0 3e    	mov    %ax,0x3ea0aa38
    896c:	aa                   	stos   %al,%es:(%edi)
      }
 
      if (!(registerB & 0x02) && (sys_internal_hour & 0x80)) {
    896d:	66 83 e6 02          	and    $0x2,%si
    8971:	75 1b                	jne    898e <read_rtc+0x236>
    8973:	84 c0                	test   %al,%al
    8975:	79 17                	jns    898e <read_rtc+0x236>
            sys_internal_hour = ((sys_internal_hour & 0x7F) + 12) % 24;
    8977:	66 83 e0 7f          	and    $0x7f,%ax
    897b:	66 83 c0 0c          	add    $0xc,%ax
    897f:	66 b9 18 00          	mov    $0x18,%cx
    8983:	00 00                	add    %al,(%eax)
    8985:	66 99                	cwtd   
    8987:	66 f7 f9             	idiv   %cx
    898a:	88 16                	mov    %dl,(%esi)
    898c:	3e aa                	ds stos %al,%es:(%edi)
      }
 
      sys_internal_year += (SYS_INTERNAL_CURRENT_YEAR / 100) * 100;
    898e:	66 a1 38 aa 67 66    	mov    0x6667aa38,%ax
    8994:	8d 90 d0 07 00 00    	lea    0x7d0(%eax),%edx
      if(sys_internal_year < SYS_INTERNAL_CURRENT_YEAR) sys_internal_year += 100;
    899a:	66 81 fa e1 07       	cmp    $0x7e1,%dx
    899f:	00 00                	add    %al,(%eax)
    89a1:	76 07                	jbe    89aa <read_rtc+0x252>
      sys_internal_year += (SYS_INTERNAL_CURRENT_YEAR / 100) * 100;
    89a3:	66 89 16             	mov    %dx,(%esi)
    89a6:	38 aa eb 0a 66 05    	cmp    %ch,0x5660aeb(%edx)
      if(sys_internal_year < SYS_INTERNAL_CURRENT_YEAR) sys_internal_year += 100;
    89ac:	34 08                	xor    $0x8,%al
    89ae:	00 00                	add    %al,(%eax)
    89b0:	66 a3 38 aa 66 0f    	mov    %ax,0xf66aa38
      sprintf(sys_internal_time_str,"%d/%d/%d-%d:%d:%d\n", sys_internal_year, sys_internal_month, sys_internal_day, sys_internal_hour, sys_internal_minute, sys_internal_second);
    89b6:	b6 06                	mov    $0x6,%dh
    89b8:	40                   	inc    %eax
    89b9:	aa                   	stos   %al,%es:(%edi)
    89ba:	66 50                	push   %ax
    89bc:	66 0f b6 06          	movzbw (%esi),%ax
    89c0:	3f                   	aas    
    89c1:	aa                   	stos   %al,%es:(%edi)
    89c2:	66 50                	push   %ax
    89c4:	66 0f b6 06          	movzbw (%esi),%ax
    89c8:	3e aa                	ds stos %al,%es:(%edi)
    89ca:	66 50                	push   %ax
    89cc:	66 0f b6 06          	movzbw (%esi),%ax
    89d0:	3d aa 66 50 66       	cmp    $0x665066aa,%eax
    89d5:	0f b6 06             	movzbl (%esi),%eax
    89d8:	3c aa                	cmp    $0xaa,%al
    89da:	66 50                	push   %ax
    89dc:	66 ff 36             	pushw  (%esi)
    89df:	38 aa 66 68 b1 bd    	cmp    %ch,-0x424e979a(%edx)
    89e5:	00 00                	add    %al,(%eax)
    89e7:	66 68 24 aa          	pushw  $0xaa24
    89eb:	00 00                	add    %al,(%eax)
    89ed:	66 e8 29 0c          	callw  961a <_Z8vsprintfPcPKcS_+0x1a9>
    89f1:	00 00                	add    %al,(%eax)
}
    89f3:	66 83 c4 20          	add    $0x20,%sp
    89f7:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    89fc:	66 5b                	pop    %bx
    89fe:	66 5e                	pop    %si
    8a00:	66 5f                	pop    %di
    8a02:	66 5d                	pop    %bp
    8a04:	66 c3                	retw   

00008a06 <_Z6memcmpPKvS0_m>:
namespace hhlibc {

#endif

int memcmp(const void * _s1, const void* _s2, size_t n)
{
    8a06:	66 55                	push   %bp
    8a08:	66 89 e5             	mov    %sp,%bp
    8a0b:	66 31 d2             	xor    %dx,%dx
    auto s1 = reinterpret_cast<const unsigned char*>(_s1);
    auto s2 = reinterpret_cast<const unsigned char*>(_s2);
    while(n--)
    8a0e:	67 66 39 55 10       	cmp    %dx,0x10(%di)
    8a13:	74 22                	je     8a37 <_Z6memcmpPKvS0_m+0x31>
    {
        if(*s1 != *s2)          //**不能**让!=时跳出然后返回*s1 - *s2
    8a15:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8a1a:	67 66 0f b6 04       	movzbw (%si),%ax
    8a1f:	10 66 42             	adc    %ah,0x42(%esi)
    8a22:	67 66 8b 4d 0c       	mov    0xc(%di),%cx
    8a27:	67 66 0f b6 4c 11    	movzbw 0x11(%si),%cx
    8a2d:	ff                   	(bad)  
    8a2e:	38 c8                	cmp    %cl,%al
    8a30:	74 dc                	je     8a0e <_Z6memcmpPKvS0_m+0x8>
        {                       //因为那样在实际上==的时候，会比较错误
            return *s1 - *s2;
    8a32:	66 29 c8             	sub    %cx,%ax
    8a35:	eb 03                	jmp    8a3a <_Z6memcmpPKvS0_m+0x34>
        }
        ++s1;
        ++s2;
    }
    return 0;
    8a37:	66 31 c0             	xor    %ax,%ax
}
    8a3a:	66 5d                	pop    %bp
    8a3c:	66 c3                	retw   

00008a3e <_Z6memcpyPvPKvm>:

void* memcpy(void* _dst, const void* _src, size_t n)
{
    8a3e:	66 55                	push   %bp
    8a40:	66 89 e5             	mov    %sp,%bp
    8a43:	66 53                	push   %bx
    8a45:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8a4a:	67 66 8b 5d 0c       	mov    0xc(%di),%bx
    8a4f:	66 31 d2             	xor    %dx,%dx
    auto dst = reinterpret_cast<unsigned char*>(_dst);
    auto src = reinterpret_cast<const unsigned char*>(_src);
    while (n--)
    8a52:	67 66 39 55 10       	cmp    %dx,0x10(%di)
    8a57:	74 0c                	je     8a65 <_Z6memcpyPvPKvm+0x27>
    {
        *(dst++) = *(src++);
    8a59:	67 8a 0c             	mov    (%si),%cl
    8a5c:	13 67 88             	adc    -0x78(%edi),%esp
    8a5f:	0c 10                	or     $0x10,%al
    8a61:	66 42                	inc    %dx
    while (n--)
    8a63:	eb ed                	jmp    8a52 <_Z6memcpyPvPKvm+0x14>
    }
    return _dst;
}
    8a65:	66 5b                	pop    %bx
    8a67:	66 5d                	pop    %bp
    8a69:	66 c3                	retw   

00008a6b <_Z7memmovePvPKvm>:
void* memmove(void* _dst, const void* _src, size_t n)
{
    8a6b:	66 55                	push   %bp
    8a6d:	66 89 e5             	mov    %sp,%bp
    8a70:	66 56                	push   %si
    8a72:	66 53                	push   %bx
    8a74:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8a79:	67 66 8b 5d 0c       	mov    0xc(%di),%bx
    8a7e:	67 66 8b 75 10       	mov    0x10(%di),%si
    auto dst = reinterpret_cast<unsigned char*>(_dst);
    auto src = reinterpret_cast<const unsigned char*>(_src);
    if(dst < src)
    8a83:	66 39 d8             	cmp    %bx,%ax
    8a86:	73 14                	jae    8a9c <_Z7memmovePvPKvm+0x31>
    8a88:	66 31 c9             	xor    %cx,%cx
    {
        while(n--)
    8a8b:	66 39 f1             	cmp    %si,%cx
    8a8e:	74 20                	je     8ab0 <_Z7memmovePvPKvm+0x45>
        {
            *(dst++) = *(src++);
    8a90:	67 8a 14             	mov    (%si),%dl
    8a93:	0b 67 88             	or     -0x78(%edi),%esp
    8a96:	14 08                	adc    $0x8,%al
    8a98:	66 41                	inc    %cx
        while(n--)
    8a9a:	eb ef                	jmp    8a8b <_Z7memmovePvPKvm+0x20>
        }
    }
    else if(dst > src)
    8a9c:	76 12                	jbe    8ab0 <_Z7memmovePvPKvm+0x45>
    {
        src += n;
        dst += n;
        while(n--)
    8a9e:	66 4e                	dec    %si
    8aa0:	66 83 fe ff          	cmp    $0xffff,%si
    8aa4:	74 0a                	je     8ab0 <_Z7memmovePvPKvm+0x45>
        {
            *(--dst) = *(--src);
    8aa6:	67 8a 0c             	mov    (%si),%cl
    8aa9:	33 67 88             	xor    -0x78(%edi),%esp
    8aac:	0c 30                	or     $0x30,%al
        while(n--)
    8aae:	eb ee                	jmp    8a9e <_Z7memmovePvPKvm+0x33>
        }
    }
    return _dst;
}
    8ab0:	66 5b                	pop    %bx
    8ab2:	66 5e                	pop    %si
    8ab4:	66 5d                	pop    %bp
    8ab6:	66 c3                	retw   

00008ab8 <_Z6memsetPvim>:
void* memset(void* _dst, int c, size_t n)
{
    8ab8:	66 55                	push   %bp
    8aba:	66 89 e5             	mov    %sp,%bp
    8abd:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8ac2:	67 66 8b 4d 0c       	mov    0xc(%di),%cx
    8ac7:	66 31 d2             	xor    %dx,%dx
    auto dst = reinterpret_cast<unsigned char*>(_dst);
    while(n--)
    8aca:	67 66 39 55 10       	cmp    %dx,0x10(%di)
    8acf:	74 08                	je     8ad9 <_Z6memsetPvim+0x21>
    {
        *(dst++) = static_cast<unsigned char>(c);
    8ad1:	67 88 0c             	mov    %cl,(%si)
    8ad4:	10 66 42             	adc    %ah,0x42(%esi)
    while(n--)
    8ad7:	eb f1                	jmp    8aca <_Z6memsetPvim+0x12>
    }
    return _dst;
}
    8ad9:	66 5d                	pop    %bp
    8adb:	66 c3                	retw   

00008add <_Z6strlenPKc>:
size_t strlen(const char* _str)
{
    8add:	66 55                	push   %bp
    8adf:	66 89 e5             	mov    %sp,%bp
    8ae2:	67 66 8b 55 08       	mov    0x8(%di),%dx
    auto str = _str;
    size_t len = 0;
    8ae7:	66 31 c0             	xor    %ax,%ax
    while(*(_str++))
    8aea:	67 80 3c 02          	cmpb   $0x2,(%si)
    8aee:	00 74 04 66          	add    %dh,0x66(%esp,%eax,1)
    {
        len++;
    8af2:	40                   	inc    %eax
    while(*(_str++))
    8af3:	eb f5                	jmp    8aea <_Z6strlenPKc+0xd>
    }
    return len;
}
    8af5:	66 5d                	pop    %bp
    8af7:	66 c3                	retw   

00008af9 <_Z6strcpyPcPKc>:
char *strcpy(char* _dst, const char* _src)
{
    8af9:	66 55                	push   %bp
    8afb:	66 89 e5             	mov    %sp,%bp
    8afe:	66 56                	push   %si
    8b00:	66 53                	push   %bx
    8b02:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    8b07:	67 66 8b 4d 0c       	mov    0xc(%di),%cx
    auto len = strlen(_src);
    8b0c:	66 51                	push   %cx
    8b0e:	66 e8 c9 ff          	callw  8adb <_Z6memsetPvim+0x23>
    8b12:	ff                   	(bad)  
    8b13:	ff 66 89             	jmp    *-0x77(%esi)
    8b16:	c6                   	(bad)  
    memcpy(reinterpret_cast<void*>(_dst), reinterpret_cast<const void *>(_src), len);
    8b17:	67 66 89 04          	mov    %ax,(%si)
    8b1b:	24 66                	and    $0x66,%al
    8b1d:	51                   	push   %ecx
    8b1e:	66 53                	push   %bx
    8b20:	66 e8 18 ff          	callw  8a3c <_Z6memcmpPKvS0_m+0x36>
    8b24:	ff                   	(bad)  
    8b25:	ff 67 c6             	jmp    *-0x3a(%edi)
    _dst[len] = '\0';
    8b28:	04 33                	add    $0x33,%al
    8b2a:	00 66 89             	add    %ah,-0x77(%esi)
    return _dst;
}
    8b2d:	d8 67 66             	fsubs  0x66(%edi)
    8b30:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8b33:	66 5b                	pop    %bx
    8b35:	66 5e                	pop    %si
    8b37:	66 5d                	pop    %bp
    8b39:	66 c3                	retw   

00008b3b <_Z6strcmpPKcS0_>:
int strcmp(const char* _s1, const char* _s2)
{
    8b3b:	66 55                	push   %bp
    8b3d:	66 89 e5             	mov    %sp,%bp
    8b40:	66 57                	push   %di
    8b42:	66 56                	push   %si
    8b44:	66 53                	push   %bx
    8b46:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    8b4b:	67 66 8b 7d 0c       	mov    0xc(%di),%di
    auto len1 = strlen(_s1);
    8b50:	66 51                	push   %cx
    8b52:	66 e8 85 ff          	callw  8adb <_Z6memsetPvim+0x23>
    8b56:	ff                   	(bad)  
    8b57:	ff 66 89             	jmp    *-0x77(%esi)
    8b5a:	c3                   	ret    
    auto len2 = strlen(_s2);
    8b5b:	67 66 89 3c          	mov    %di,(%si)
    8b5f:	24 66                	and    $0x66,%al
    8b61:	e8 77 ff ff ff       	call   8add <_Z6strlenPKc>
    8b66:	66 5a                	pop    %dx
    8b68:	66 89 c6             	mov    %ax,%si
    auto len = len1 < len2 ? len1 : len2;
    auto ret = memcmp(reinterpret_cast<const void*>(_s1), reinterpret_cast<const void *>(_s2), len);
    8b6b:	66 39 c3             	cmp    %ax,%bx
    8b6e:	77 03                	ja     8b73 <_Z6strcmpPKcS0_+0x38>
    8b70:	66 89 d8             	mov    %bx,%ax
    8b73:	66 50                	push   %ax
    8b75:	66 57                	push   %di
    8b77:	66 51                	push   %cx
    8b79:	66 e8 87 fe          	callw  8a04 <read_rtc+0x2ac>
    8b7d:	ff                   	(bad)  
    8b7e:	ff 66 83             	jmp    *-0x7d(%esi)
    8b81:	c4 0c 66             	les    (%esi,%eiz,2),%ecx
    if(ret == 0)
    8b84:	85 c0                	test   %eax,%eax
    8b86:	75 11                	jne    8b99 <_Z6strcmpPKcS0_+0x5e>
    {
        if(len1 == len2)
    8b88:	66 39 f3             	cmp    %si,%bx
    8b8b:	74 0c                	je     8b99 <_Z6strcmpPKcS0_+0x5e>
        {
            return -1;
        }
        else
        {
            return 1;
    8b8d:	66 39 de             	cmp    %bx,%si
    8b90:	66 19 c0             	sbb    %ax,%ax
    8b93:	66 83 e0 02          	and    $0x2,%ax
    8b97:	66 48                	dec    %ax
        }
    }
    return ret;
}
    8b99:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    8b9e:	66 5b                	pop    %bx
    8ba0:	66 5e                	pop    %si
    8ba2:	66 5f                	pop    %di
    8ba4:	66 5d                	pop    %bp
    8ba6:	66 c3                	retw   

00008ba8 <_Z7reversePc>:

void reverse(char* buffer)
{
    8ba8:	66 55                	push   %bp
    8baa:	66 89 e5             	mov    %sp,%bp
    8bad:	66 56                	push   %si
    8baf:	66 53                	push   %bx
    8bb1:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    char ch;
    size_t len = strlen(buffer);
    8bb6:	66 51                	push   %cx
    8bb8:	66 e8 1f ff          	callw  8adb <_Z6memsetPvim+0x23>
    8bbc:	ff                   	(bad)  
    8bbd:	ff 66 5a             	jmp    *0x5a(%esi)
    8bc0:	66 89 ca             	mov    %cx,%dx
    8bc3:	67 66 8d 0c          	lea    (%si),%cx
    8bc7:	01 66 d1             	add    %esp,-0x2f(%esi)
    for(size_t i = 0; i < len / 2; ++i)
    8bca:	e8 67 66 8d 34       	call   348df236 <_GLOBAL_OFFSET_TABLE_+0x348d344e>
    8bcf:	10 66 49             	adc    %ah,0x49(%esi)
    8bd2:	66 39 f2             	cmp    %si,%dx
    8bd5:	74 10                	je     8be7 <_Z7reversePc+0x3f>
    {
        ch = *(buffer + i);
    8bd7:	67 8a 1a             	mov    (%bp,%si),%bl
        *(buffer + i) = *(buffer + len - 1 - i);
    8bda:	67 8a 01             	mov    (%bx,%di),%al
    8bdd:	67 88 02             	mov    %al,(%bp,%si)
        *(buffer + len - 1 - i)  = ch;
    8be0:	67 88 19             	mov    %bl,(%bx,%di)
    8be3:	66 42                	inc    %dx
    for(size_t i = 0; i < len / 2; ++i)
    8be5:	eb e9                	jmp    8bd0 <_Z7reversePc+0x28>
    }
}
    8be7:	67 66 8d 65 f8       	lea    -0x8(%di),%sp
    8bec:	66 5b                	pop    %bx
    8bee:	66 5e                	pop    %si
    8bf0:	66 5d                	pop    %bp
    8bf2:	66 c3                	retw   

00008bf4 <_Z7isspacei>:
namespace hhlibc {

#endif

int isspace( int ch )
{
    8bf4:	66 55                	push   %bp
    8bf6:	66 89 e5             	mov    %sp,%bp
    8bf9:	67 66 8b 55 08       	mov    0x8(%di),%dx
    return (ch == 9 || ch == 32 || (ch >= 10 && ch <= 13));
    8bfe:	67 66 8d 42 f7       	lea    -0x9(%bp,%si),%ax
    8c03:	66 83 f8 04          	cmp    $0x4,%ax
    8c07:	0f 96 c0             	setbe  %al
    8c0a:	66 83 fa 20          	cmp    $0x20,%dx
    8c0e:	0f 94 c2             	sete   %dl
    8c11:	66 09 d0             	or     %dx,%ax
    8c14:	66 0f b6 c0          	movzbw %al,%ax
}
    8c18:	66 5d                	pop    %bp
    8c1a:	66 c3                	retw   

00008c1c <_Z7isdigiti>:
{
    return isdigit(ch) || isalpha(ch);
}

int isdigit(int ch)
{
    8c1c:	66 55                	push   %bp
    8c1e:	66 89 e5             	mov    %sp,%bp
    return (ch >= 48 && ch <= 57);
    8c21:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8c26:	66 83 e8 30          	sub    $0x30,%ax
    8c2a:	66 83 f8 09          	cmp    $0x9,%ax
    8c2e:	0f 96 c0             	setbe  %al
    8c31:	66 0f b6 c0          	movzbw %al,%ax
}
    8c35:	66 5d                	pop    %bp
    8c37:	66 c3                	retw   

00008c39 <_Z7isalphai>:

int isalpha(int ch)
{
    8c39:	66 55                	push   %bp
    8c3b:	66 89 e5             	mov    %sp,%bp
    return  isupper(ch)||islower(ch);
    8c3e:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8c43:	66 83 e0 df          	and    $0xffdf,%ax
    8c47:	66 83 e8 41          	sub    $0x41,%ax
    8c4b:	66 83 f8 19          	cmp    $0x19,%ax
    8c4f:	0f 96 c0             	setbe  %al
    8c52:	66 0f b6 c0          	movzbw %al,%ax
}
    8c56:	66 5d                	pop    %bp
    8c58:	66 c3                	retw   

00008c5a <_Z7isalnumi>:
{
    8c5a:	66 55                	push   %bp
    8c5c:	66 89 e5             	mov    %sp,%bp
    8c5f:	67 66 8b 55 08       	mov    0x8(%di),%dx
    return (ch >= 48 && ch <= 57);
    8c64:	67 66 8d 4a d0       	lea    -0x30(%bp,%si),%cx
    8c69:	b0 01                	mov    $0x1,%al
    return isdigit(ch) || isalpha(ch);
    8c6b:	66 83 f9 09          	cmp    $0x9,%cx
    8c6f:	76 10                	jbe    8c81 <_Z7isalnumi+0x27>
    8c71:	66 52                	push   %dx
    8c73:	66 e8 c0 ff          	callw  8c37 <_Z7isdigiti+0x1b>
    8c77:	ff                   	(bad)  
    8c78:	ff 66 5a             	jmp    *0x5a(%esi)
    8c7b:	66 85 c0             	test   %ax,%ax
    8c7e:	0f 95 c0             	setne  %al
    8c81:	66 0f b6 c0          	movzbw %al,%ax
}
    8c85:	66 c9                	leavew 
    8c87:	66 c3                	retw   

00008c89 <_Z7isupperi>:
int isupper(int ch)
{
    8c89:	66 55                	push   %bp
    8c8b:	66 89 e5             	mov    %sp,%bp
    return (ch >= 65 && ch <= 90);
    8c8e:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8c93:	66 83 e8 41          	sub    $0x41,%ax
    8c97:	66 83 f8 19          	cmp    $0x19,%ax
    8c9b:	0f 96 c0             	setbe  %al
    8c9e:	66 0f b6 c0          	movzbw %al,%ax
}
    8ca2:	66 5d                	pop    %bp
    8ca4:	66 c3                	retw   

00008ca6 <_Z7isloweri>:

int islower(int ch)
{
    8ca6:	66 55                	push   %bp
    8ca8:	66 89 e5             	mov    %sp,%bp
    return (ch >= 97 && ch <= 122);
    8cab:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8cb0:	66 83 e8 61          	sub    $0x61,%ax
    8cb4:	66 83 f8 19          	cmp    $0x19,%ax
    8cb8:	0f 96 c0             	setbe  %al
    8cbb:	66 0f b6 c0          	movzbw %al,%ax
}
    8cbf:	66 5d                	pop    %bp
    8cc1:	66 c3                	retw   

00008cc3 <_Z7iscntrli>:

int iscntrl(int ch)
{
    8cc3:	66 55                	push   %bp
    8cc5:	66 89 e5             	mov    %sp,%bp
    8cc8:	67 66 8b 55 08       	mov    0x8(%di),%dx
    return (ch >= 0 && ch <=31) || ch == 127;
    8ccd:	66 83 fa 7f          	cmp    $0x7f,%dx
    8cd1:	0f 94 c0             	sete   %al
    8cd4:	66 83 fa 1f          	cmp    $0x1f,%dx
    8cd8:	0f 96 c2             	setbe  %dl
    8cdb:	66 09 d0             	or     %dx,%ax
    8cde:	66 0f b6 c0          	movzbw %al,%ax
}
    8ce2:	66 5d                	pop    %bp
    8ce4:	66 c3                	retw   

00008ce6 <_Z7isgraphi>:

int isgraph(int ch)
{
    8ce6:	66 55                	push   %bp
    8ce8:	66 89 e5             	mov    %sp,%bp
    return (ch >= 33 && ch <= 126);
    8ceb:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8cf0:	66 83 e8 21          	sub    $0x21,%ax
    8cf4:	66 83 f8 5d          	cmp    $0x5d,%ax
    8cf8:	0f 96 c0             	setbe  %al
    8cfb:	66 0f b6 c0          	movzbw %al,%ax
}
    8cff:	66 5d                	pop    %bp
    8d01:	66 c3                	retw   

00008d03 <_Z7isprinti>:

int isprint(int ch)
{
    8d03:	66 55                	push   %bp
    8d05:	66 89 e5             	mov    %sp,%bp
    return (ch >= 32 && ch <= 126);
    8d08:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8d0d:	66 83 e8 20          	sub    $0x20,%ax
    8d11:	66 83 f8 5e          	cmp    $0x5e,%ax
    8d15:	0f 96 c0             	setbe  %al
    8d18:	66 0f b6 c0          	movzbw %al,%ax
}
    8d1c:	66 5d                	pop    %bp
    8d1e:	66 c3                	retw   

00008d20 <_Z7ispuncti>:

int ispunct(int ch)
{
    8d20:	66 55                	push   %bp
    8d22:	66 89 e5             	mov    %sp,%bp
    8d25:	67 66 8b 55 08       	mov    0x8(%di),%dx
    return (ch >= 33 && ch <=47) || (ch >= 58 && ch <=64) 
    8d2a:	67 66 8d 4a df       	lea    -0x21(%bp,%si),%cx
            || (ch >= 91 && ch <= 96) || (ch >= 123 && ch <= 126);
    8d2f:	b0 01                	mov    $0x1,%al
    8d31:	66 83 f9 0e          	cmp    $0xe,%cx
    8d35:	76 21                	jbe    8d58 <_Z7ispuncti+0x38>
    return (ch >= 33 && ch <=47) || (ch >= 58 && ch <=64) 
    8d37:	67 66 8d 4a c6       	lea    -0x3a(%bp,%si),%cx
    8d3c:	66 83 f9 06          	cmp    $0x6,%cx
    8d40:	76 16                	jbe    8d58 <_Z7ispuncti+0x38>
            || (ch >= 91 && ch <= 96) || (ch >= 123 && ch <= 126);
    8d42:	67 66 8d 4a a5       	lea    -0x5b(%bp,%si),%cx
    8d47:	66 83 f9 05          	cmp    $0x5,%cx
    8d4b:	76 0b                	jbe    8d58 <_Z7ispuncti+0x38>
    8d4d:	66 83 ea 7b          	sub    $0x7b,%dx
    8d51:	66 83 fa 03          	cmp    $0x3,%dx
    8d55:	0f 96 c0             	setbe  %al
    8d58:	66 0f b6 c0          	movzbw %al,%ax
}
    8d5c:	66 5d                	pop    %bp
    8d5e:	66 c3                	retw   

00008d60 <_Z8isxdigiti>:

int isxdigit(int ch)
{
    8d60:	66 55                	push   %bp
    8d62:	66 89 e5             	mov    %sp,%bp
    8d65:	67 66 8b 55 08       	mov    0x8(%di),%dx
    return (ch >= 48 && ch <= 57);
    8d6a:	67 66 8d 4a d0       	lea    -0x30(%bp,%si),%cx
    8d6f:	b0 01                	mov    $0x1,%al
    return isdigit(ch) || (ch >= 65 && ch <= 70) || (ch >= 97 && ch <= 102);
    8d71:	66 83 f9 09          	cmp    $0x9,%cx
    8d75:	76 0f                	jbe    8d86 <_Z8isxdigiti+0x26>
    8d77:	66 83 e2 df          	and    $0xffdf,%dx
    8d7b:	66 83 ea 41          	sub    $0x41,%dx
    8d7f:	66 83 fa 05          	cmp    $0x5,%dx
    8d83:	0f 96 c0             	setbe  %al
    8d86:	66 0f b6 c0          	movzbw %al,%ax
}
    8d8a:	66 5d                	pop    %bp
    8d8c:	66 c3                	retw   

00008d8e <_Z7toloweri>:
int tolower(int ch)
{
    8d8e:	66 55                	push   %bp
    8d90:	66 89 e5             	mov    %sp,%bp
    return ch + 0x20;
    8d93:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8d98:	66 83 c0 20          	add    $0x20,%ax
}
    8d9c:	66 5d                	pop    %bp
    8d9e:	66 c3                	retw   

00008da0 <_Z7toupperi>:
int toupper(int ch)
{
    8da0:	66 55                	push   %bp
    8da2:	66 89 e5             	mov    %sp,%bp
    return ch - 0x20;
    8da5:	67 66 8b 45 08       	mov    0x8(%di),%ax
    8daa:	66 83 e8 20          	sub    $0x20,%ax
}
    8dae:	66 5d                	pop    %bp
    8db0:	66 c3                	retw   

00008db2 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0>:
    if(base == 0 && !auto_detected)
    {
        base = 10;
        auto_detected = true;
    }
    auto char_to_digit = [](auto ch){
    8db2:	66 55                	push   %bp
    8db4:	66 89 e5             	mov    %sp,%bp
    8db7:	66 89 c2             	mov    %ax,%dx
        int digit;
        if(ch >= '0' && ch <= '9')
    8dba:	66 83 e8 30          	sub    $0x30,%ax
    8dbe:	3c 09                	cmp    $0x9,%al
    8dc0:	77 0b                	ja     8dcd <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x1b>
            digit = ch - '0';
    8dc2:	66 0f be d2          	movsbw %dl,%dx
    8dc6:	67 66 8d 42 d0       	lea    -0x30(%bp,%si),%ax
    8dcb:	eb 2b                	jmp    8df8 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x46>
        else if(ch >='A' && ch <= 'F')
    8dcd:	67 66 8d 42 bf       	lea    -0x41(%bp,%si),%ax
    8dd2:	3c 05                	cmp    $0x5,%al
    8dd4:	77 0b                	ja     8de1 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x2f>
            digit = ch - 'A' + 10;
    8dd6:	66 0f be d2          	movsbw %dl,%dx
    8dda:	67 66 8d 42 c9       	lea    -0x37(%bp,%si),%ax
    8ddf:	eb 17                	jmp    8df8 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x46>
        else if(ch >='a' && ch <= 'f')
    8de1:	67 66 8d 4a 9f       	lea    -0x61(%bp,%si),%cx
            digit = ch - 'a' + 10;
        else
            digit = -1;
    8de6:	66 83 c8 ff          	or     $0xffff,%ax
        else if(ch >='a' && ch <= 'f')
    8dea:	80 f9 05             	cmp    $0x5,%cl
    8ded:	77 09                	ja     8df8 <_ZZ6strtolPKcPPciENKUlT_E_clIcEEDaS3_.constprop.0+0x46>
            digit = ch - 'a' + 10;
    8def:	66 0f be d2          	movsbw %dl,%dx
    8df3:	67 66 8d 42 a9       	lea    -0x57(%bp,%si),%ax
        return digit;
    };
    8df8:	66 5d                	pop    %bp
    8dfa:	66 c3                	retw   

00008dfc <_Z5abortv>:
{
    8dfc:	66 55                	push   %bp
    8dfe:	66 89 e5             	mov    %sp,%bp
    asm volatile ("int $0x20\n\t");
    8e01:	cd 20                	int    $0x20
}
    8e03:	66 5d                	pop    %bp
    8e05:	66 c3                	retw   

00008e07 <_Z3absi>:
{
    8e07:	66 55                	push   %bp
    8e09:	66 89 e5             	mov    %sp,%bp
    8e0c:	67 66 8b 45 08       	mov    0x8(%di),%ax
    return n > 0 ? n : -n;
    8e11:	66 99                	cwtd   
    8e13:	66 31 d0             	xor    %dx,%ax
    8e16:	66 29 d0             	sub    %dx,%ax
}
    8e19:	66 5d                	pop    %bp
    8e1b:	66 c3                	retw   

00008e1d <_Z4labsl>:
{
    8e1d:	66 55                	push   %bp
    8e1f:	66 89 e5             	mov    %sp,%bp
    8e22:	67 66 8b 45 08       	mov    0x8(%di),%ax
    return n > 0 ? n : -n;
    8e27:	66 99                	cwtd   
    8e29:	66 31 d0             	xor    %dx,%ax
    8e2c:	66 29 d0             	sub    %dx,%ax
}
    8e2f:	66 5d                	pop    %bp
    8e31:	66 c3                	retw   

00008e33 <_Z3divii>:
{
    8e33:	66 55                	push   %bp
    8e35:	66 89 e5             	mov    %sp,%bp
    8e38:	66 57                	push   %di
    8e3a:	66 56                	push   %si
    8e3c:	66 53                	push   %bx
    8e3e:	66 83 ec 0c          	sub    $0xc,%sp
    8e42:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    8e47:	67 66 8b 75 10       	mov    0x10(%di),%si
    if(x == 0) return div_t{0, 0};
    8e4c:	67 66 83 7d 0c 00    	cmpw   $0x0,0xc(%di)
    8e52:	75 13                	jne    8e67 <_Z3divii+0x34>
    8e54:	67 66 c7 03 00 00    	movw   $0x0,(%bp,%di)
    8e5a:	00 00                	add    %al,(%eax)
    8e5c:	67 66 c7 43 04 00 00 	movw   $0x0,0x4(%bp,%di)
    8e63:	00 00                	add    %al,(%eax)
    8e65:	eb 63                	jmp    8eca <_Z3divii+0x97>
    div_t r = div(x/2, y);
    8e67:	67 66 8d 7d ec       	lea    -0x14(%di),%di
    8e6c:	66 56                	push   %si
    8e6e:	66 b9 02 00          	mov    $0x2,%cx
    8e72:	00 00                	add    %al,(%eax)
    8e74:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    8e79:	66 99                	cwtd   
    8e7b:	66 f7 f9             	idiv   %cx
    8e7e:	66 50                	push   %ax
    8e80:	66 57                	push   %di
    8e82:	66 e8 ab ff          	callw  8e31 <_Z4labsl+0x14>
    8e86:	ff                   	(bad)  
    8e87:	ff 67 66             	jmp    *0x66(%edi)
    8e8a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8e8d:	67 66 8b 45 f0       	mov    -0x10(%di),%ax
    r.quot = 2 * r.quot;
    8e92:	67 66 8d 3c          	lea    (%si),%di
    8e96:	12 67 66             	adc    0x66(%edi),%ah
    8e99:	89 7d e8             	mov    %edi,-0x18(%ebp)
    8e9c:	66 89 f9             	mov    %di,%cx
    r.rem = 2 * r.rem;
    8e9f:	66 01 c0             	add    %ax,%ax
    if(x % 2) r.rem = r.rem + 1;
    8ea2:	66 5a                	pop    %dx
    8ea4:	66 5f                	pop    %di
    8ea6:	66 31 d2             	xor    %dx,%dx
    8ea9:	67 f6 45 0c 01       	testb  $0x1,0xc(%di)
    8eae:	0f 95 c2             	setne  %dl
    8eb1:	66 89 d7             	mov    %dx,%di
    8eb4:	66 01 f8             	add    %di,%ax
    if(r.rem >= y) 
    8eb7:	66 39 c6             	cmp    %ax,%si
    8eba:	7f 05                	jg     8ec1 <_Z3divii+0x8e>
        r.quot = r.quot + 1;
    8ebc:	66 41                	inc    %cx
        r.rem = r.rem - y;
    8ebe:	66 29 f0             	sub    %si,%ax
    return r;
    8ec1:	67 66 89 0b          	mov    %cx,(%bp,%di)
    8ec5:	67 66 89 43 04       	mov    %ax,0x4(%bp,%di)
}
    8eca:	66 89 d8             	mov    %bx,%ax
    8ecd:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    8ed2:	66 5b                	pop    %bx
    8ed4:	66 5e                	pop    %si
    8ed6:	66 5f                	pop    %di
    8ed8:	66 5d                	pop    %bp
    8eda:	66 c2 04 00          	retw   $0x4

00008ede <_Z4ldivll>:
{
    8ede:	66 55                	push   %bp
    8ee0:	66 89 e5             	mov    %sp,%bp
    8ee3:	66 57                	push   %di
    8ee5:	66 56                	push   %si
    8ee7:	66 53                	push   %bx
    8ee9:	66 83 ec 0c          	sub    $0xc,%sp
    8eed:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    8ef2:	67 66 8b 75 10       	mov    0x10(%di),%si
    if(x == 0) return ldiv_t{0, 0};
    8ef7:	67 66 83 7d 0c 00    	cmpw   $0x0,0xc(%di)
    8efd:	75 13                	jne    8f12 <_Z4ldivll+0x34>
    8eff:	67 66 c7 03 00 00    	movw   $0x0,(%bp,%di)
    8f05:	00 00                	add    %al,(%eax)
    8f07:	67 66 c7 43 04 00 00 	movw   $0x0,0x4(%bp,%di)
    8f0e:	00 00                	add    %al,(%eax)
    8f10:	eb 63                	jmp    8f75 <_Z4ldivll+0x97>
    ldiv_t r = ldiv(x/2, y);
    8f12:	67 66 8d 7d ec       	lea    -0x14(%di),%di
    8f17:	66 56                	push   %si
    8f19:	66 b9 02 00          	mov    $0x2,%cx
    8f1d:	00 00                	add    %al,(%eax)
    8f1f:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    8f24:	66 99                	cwtd   
    8f26:	66 f7 f9             	idiv   %cx
    8f29:	66 50                	push   %ax
    8f2b:	66 57                	push   %di
    8f2d:	66 e8 ab ff          	callw  8edc <_Z3divii+0xa9>
    8f31:	ff                   	(bad)  
    8f32:	ff 67 66             	jmp    *0x66(%edi)
    8f35:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8f38:	67 66 8b 45 f0       	mov    -0x10(%di),%ax
    r.quot = 2 * r.quot;
    8f3d:	67 66 8d 3c          	lea    (%si),%di
    8f41:	12 67 66             	adc    0x66(%edi),%ah
    8f44:	89 7d e8             	mov    %edi,-0x18(%ebp)
    8f47:	66 89 f9             	mov    %di,%cx
    r.rem = 2 * r.rem;
    8f4a:	66 01 c0             	add    %ax,%ax
    if(x % 2) r.rem = r.rem + 1;
    8f4d:	66 5a                	pop    %dx
    8f4f:	66 5f                	pop    %di
    8f51:	66 31 d2             	xor    %dx,%dx
    8f54:	67 f6 45 0c 01       	testb  $0x1,0xc(%di)
    8f59:	0f 95 c2             	setne  %dl
    8f5c:	66 89 d7             	mov    %dx,%di
    8f5f:	66 01 f8             	add    %di,%ax
    if(r.rem >= y) 
    8f62:	66 39 c6             	cmp    %ax,%si
    8f65:	7f 05                	jg     8f6c <_Z4ldivll+0x8e>
        r.quot = r.quot + 1;
    8f67:	66 41                	inc    %cx
        r.rem = r.rem - y;
    8f69:	66 29 f0             	sub    %si,%ax
    return r;
    8f6c:	67 66 89 0b          	mov    %cx,(%bp,%di)
    8f70:	67 66 89 43 04       	mov    %ax,0x4(%bp,%di)
}
    8f75:	66 89 d8             	mov    %bx,%ax
    8f78:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    8f7d:	66 5b                	pop    %bx
    8f7f:	66 5e                	pop    %si
    8f81:	66 5f                	pop    %di
    8f83:	66 5d                	pop    %bp
    8f85:	66 c2 04 00          	retw   $0x4

00008f89 <_Z6strtolPKcPPci>:
{
    8f89:	66 55                	push   %bp
    8f8b:	66 89 e5             	mov    %sp,%bp
    8f8e:	66 57                	push   %di
    8f90:	66 56                	push   %si
    8f92:	66 53                	push   %bx
    8f94:	66 83 ec 0c          	sub    $0xc,%sp
    8f98:	67 66 8b 75 10       	mov    0x10(%di),%si
    auto start = str;   
    8f9d:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    while(isspace(*start))
    8fa2:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    8fa7:	66 50                	push   %ax
    8fa9:	66 e8 45 fc          	callw  8bf2 <_Z7reversePc+0x4a>
    8fad:	ff                   	(bad)  
    8fae:	ff 66 5f             	jmp    *0x5f(%esi)
    8fb1:	66 85 c0             	test   %ax,%ax
    8fb4:	74 04                	je     8fba <_Z6strtolPKcPPci+0x31>
        ++start;
    8fb6:	66 43                	inc    %bx
    while(isspace(*start))
    8fb8:	eb e8                	jmp    8fa2 <_Z6strtolPKcPPci+0x19>
    size_t len_num = strlen(start);//非白空格数字串长度
    8fba:	66 53                	push   %bx
    8fbc:	66 e8 1b fb          	callw  8adb <_Z6memsetPvim+0x23>
    8fc0:	ff                   	(bad)  
    8fc1:	ff 66 59             	jmp    *0x59(%esi)
    if(len_num == 0)
    8fc4:	66 85 c0             	test   %ax,%ax
    8fc7:	75 1e                	jne    8fe7 <_Z6strtolPKcPPci+0x5e>
        return 0;
    8fc9:	66 31 c0             	xor    %ax,%ax
        if(str_end) *str_end = const_cast<char*>(str);
    8fcc:	67 66 83 7d 0c 00    	cmpw   $0x0,0xc(%di)
    8fd2:	0f 84 4d 01 67 66    	je     66679125 <_GLOBAL_OFFSET_TABLE_+0x6666d33d>
    8fd8:	8b 7d 0c             	mov    0xc(%ebp),%edi
    8fdb:	67 66 8b 75 08       	mov    0x8(%di),%si
    8fe0:	67 66 89 37          	mov    %si,(%bx)
    8fe4:	e9 3c 01 67 8a       	jmp    8a679125 <_GLOBAL_OFFSET_TABLE_+0x8a66d33d>
    if(*high == '+' || *high == '-')
    8fe9:	13 80 fa 2b 74 10    	adc    0x10742bfa(%eax),%eax
    8fef:	80 fa 2d             	cmp    $0x2d,%dl
    8ff2:	75 21                	jne    9015 <_Z6strtolPKcPPci+0x8c>
        sign = (*high == '+') ? 1 : -1;
    8ff4:	67 66 c7 45 f0 ff ff 	movw   $0xffff,-0x10(%di)
    8ffb:	ff                   	(bad)  
    8ffc:	ff                   	(bad)  
    8ffd:	eb 09                	jmp    9008 <_Z6strtolPKcPPci+0x7f>
    8fff:	67 66 c7 45 f0 01 00 	movw   $0x1,-0x10(%di)
    9006:	00 00                	add    %al,(%eax)
        ++high;
    9008:	67 66 8d 7b 01       	lea    0x1(%bp,%di),%di
        sign_char_bit = 1;
    900d:	66 ba 01 00          	mov    $0x1,%dx
    9011:	00 00                	add    %al,(%eax)
    9013:	eb 0f                	jmp    9024 <_Z6strtolPKcPPci+0x9b>
    9015:	66 89 df             	mov    %bx,%di
    size_t sign_char_bit = 0;
    9018:	66 31 d2             	xor    %dx,%dx
    int sign = 1;
    901b:	67 66 c7 45 f0 01 00 	movw   $0x1,-0x10(%di)
    9022:	00 00                	add    %al,(%eax)
    if(base == 16 || (base == 0 && !auto_detected))
    9024:	66 f7 c6 ef ff       	test   $0xffef,%si
    9029:	ff                   	(bad)  
    902a:	ff 75 29             	pushl  0x29(%ebp)
        if(len_num > 1 + sign_char_bit && 
    902d:	67 66 8d 4a 01       	lea    0x1(%bp,%si),%cx
    9032:	66 39 c1             	cmp    %ax,%cx
    9035:	73 1f                	jae    9056 <_Z6strtolPKcPPci+0xcd>
    9037:	67 80 3f 30          	cmpb   $0x30,(%bx)
    903b:	75 19                	jne    9056 <_Z6strtolPKcPPci+0xcd>
           (*(high + 1) == 'x' || *(high + 1) == 'X'))
    903d:	67 8a 4f 01          	mov    0x1(%bx),%cl
    9041:	66 83 e1 df          	and    $0xffdf,%cx
    9045:	80 f9 58             	cmp    $0x58,%cl
    9048:	75 0c                	jne    9056 <_Z6strtolPKcPPci+0xcd>
             high += 2;
    904a:	66 83 c7 02          	add    $0x2,%di
             base = 16;
    904e:	66 be 10 00          	mov    $0x10,%si
    9052:	00 00                	add    %al,(%eax)
    9054:	eb 2b                	jmp    9081 <_Z6strtolPKcPPci+0xf8>
    if(base == 8 || (base == 0 && !auto_detected))
    9056:	66 83 fe 08          	cmp    $0x8,%si
    905a:	74 05                	je     9061 <_Z6strtolPKcPPci+0xd8>
    905c:	66 85 f6             	test   %si,%si
    905f:	75 20                	jne    9081 <_Z6strtolPKcPPci+0xf8>
        if(len_num > sign_char_bit && *high == 0)   //存在八进制前缀0
    9061:	66 39 c2             	cmp    %ax,%dx
    9064:	73 10                	jae    9076 <_Z6strtolPKcPPci+0xed>
    9066:	67 80 3f 00          	cmpb   $0x0,(%bx)
    906a:	75 0a                	jne    9076 <_Z6strtolPKcPPci+0xed>
            high += 1;
    906c:	66 47                	inc    %di
            base = 8;
    906e:	66 be 08 00          	mov    $0x8,%si
    9072:	00 00                	add    %al,(%eax)
    9074:	eb 0b                	jmp    9081 <_Z6strtolPKcPPci+0xf8>
    if(base == 0 && !auto_detected)
    9076:	66 85 f6             	test   %si,%si
    9079:	75 06                	jne    9081 <_Z6strtolPKcPPci+0xf8>
        base = 10;
    907b:	66 be 0a 00          	mov    $0xa,%si
    907f:	00 00                	add    %al,(%eax)
    bool has_vaild_char = false;
    9081:	67 c6 45 ec 00       	movb   $0x0,-0x14(%di)
    auto low = start;   
    //使low指向数字低位后的一个位置
    while(!isspace(*low) &&             //判断是否是白空格
    9086:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    908b:	66 50                	push   %ax
    908d:	66 e8 61 fb          	callw  8bf2 <_Z7reversePc+0x4a>
    9091:	ff                   	(bad)  
    9092:	ff 66 5a             	jmp    *0x5a(%esi)
          (*low != '\0') &&             //判断是否字符串结束
          char_to_digit(*low) != -1 &&  //判断是否是合法数字
    9095:	66 85 c0             	test   %ax,%ax
    9098:	75 28                	jne    90c2 <_Z6strtolPKcPPci+0x139>
          (*low != '\0') &&             //判断是否字符串结束
    909a:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    while(!isspace(*low) &&             //判断是否是白空格
    909f:	84 c0                	test   %al,%al
    90a1:	74 1f                	je     90c2 <_Z6strtolPKcPPci+0x139>
          char_to_digit(*low) != -1 &&  //判断是否是合法数字
    90a3:	66 e8 09 fd          	callw  8db0 <_Z7toupperi+0x10>
    90a7:	ff                   	(bad)  
    90a8:	ff 66 83             	jmp    *-0x7d(%esi)
          (*low != '\0') &&             //判断是否字符串结束
    90ab:	f8                   	clc    
    90ac:	ff 0f                	decl   (%edi)
    90ae:	95                   	xchg   %eax,%ebp
    90af:	c2 66 39             	ret    $0x3966
          char_to_digit(*low) != -1 &&  //判断是否是合法数字
    90b2:	f0 0f 9c c0          	lock setl %al
    90b6:	20 c2                	and    %al,%dl
    90b8:	74 08                	je     90c2 <_Z6strtolPKcPPci+0x139>
          char_to_digit(*low) < base    //判断是否是该进制
          )
    {
        ++low;
    90ba:	66 43                	inc    %bx
        has_vaild_char = true;
    90bc:	67 88 55 ec          	mov    %dl,-0x14(%di)
    while(!isspace(*low) &&             //判断是否是白空格
    90c0:	eb c4                	jmp    9086 <_Z6strtolPKcPPci+0xfd>
    }
    if(!has_vaild_char)
    90c2:	67 80 7d ec 00       	cmpb   $0x0,-0x14(%di)
    90c7:	0f 84 fe fe 67 66    	je     66688fcb <_GLOBAL_OFFSET_TABLE_+0x6667d1e3>
        if (str_end) *str_end = const_cast<char*>(str);
        return 0;
    }
    long power = 1;
    long ret = 0;
    if(str_end) *str_end = const_cast<char*>(low);
    90cd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    90d1:	74 09                	je     90dc <_Z6strtolPKcPPci+0x153>
    90d3:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    90d8:	67 66 89 18          	mov    %bx,(%bx,%si)
    for(auto p = low - 1; p >= high; --p)
    90dc:	66 4b                	dec    %bx
    long ret = 0;
    90de:	66 31 c9             	xor    %cx,%cx
    long power = 1;
    90e1:	66 ba 01 00          	mov    $0x1,%dx
    90e5:	00 00                	add    %al,(%eax)
    90e7:	67 66 89 55 e8       	mov    %dx,-0x18(%di)
    for(auto p = low - 1; p >= high; --p)
    90ec:	66 39 fb             	cmp    %di,%bx
    90ef:	72 29                	jb     911a <_Z6strtolPKcPPci+0x191>
    90f1:	67 66 89 4d ec       	mov    %cx,-0x14(%di)
    {
        int digit = char_to_digit(*p);
    90f6:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    90fb:	66 e8 b1 fc          	callw  8db0 <_Z7toupperi+0x10>
    90ff:	ff                   	(bad)  
    9100:	ff 67 66             	jmp    *0x66(%edi)
        ret += power * digit;
    9103:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9106:	66 0f af c2          	imul   %dx,%ax
    910a:	67 66 8b 4d ec       	mov    -0x14(%di),%cx
    910f:	66 01 c1             	add    %ax,%cx
        
        power *= base;
    9112:	66 0f af d6          	imul   %si,%dx
    for(auto p = low - 1; p >= high; --p)
    9116:	66 4b                	dec    %bx
    9118:	eb cd                	jmp    90e7 <_Z6strtolPKcPPci+0x15e>
    }
    ret *= sign;
    911a:	67 66 8b 45 f0       	mov    -0x10(%di),%ax
    911f:	66 0f af c1          	imul   %cx,%ax
    return ret;
}
    9123:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    9128:	66 5b                	pop    %bx
    912a:	66 5e                	pop    %si
    912c:	66 5f                	pop    %di
    912e:	66 5d                	pop    %bp
    9130:	66 c3                	retw   

00009132 <_Z4atoiPKc>:
{
    9132:	66 55                	push   %bp
    9134:	66 89 e5             	mov    %sp,%bp
    return (int)strtol(s, (char**)nullptr, 10);
    9137:	66 6a 0a             	pushw  $0xa
    913a:	66 6a 00             	pushw  $0x0
    913d:	67 66 ff 75 08       	pushw  0x8(%di)
    9142:	66 e8 41 fe          	callw  8f87 <_Z4ldivll+0xa9>
    9146:	ff                   	(bad)  
    9147:	ff 66 c9             	jmp    *-0x37(%esi)
}
    914a:	66 c3                	retw   

0000914c <_Z4atolPKc>:
{
    914c:	66 55                	push   %bp
    914e:	66 89 e5             	mov    %sp,%bp
    return strtol(s, (char**)nullptr, 10);
    9151:	66 6a 0a             	pushw  $0xa
    9154:	66 6a 00             	pushw  $0x0
    9157:	67 66 ff 75 08       	pushw  0x8(%di)
    915c:	66 e8 27 fe          	callw  8f87 <_Z4ldivll+0xa9>
    9160:	ff                   	(bad)  
    9161:	ff 66 c9             	jmp    *-0x37(%esi)
}
    9164:	66 c3                	retw   

00009166 <_ZL19system_call_putchari>:
    int mask = 0x00FF;
    ret = ret & mask;
    return ret;
}
static inline void system_call_putchar(int ch)
{
    9166:	66 55                	push   %bp
    9168:	66 89 e5             	mov    %sp,%bp
    916b:	66 53                	push   %bx
    916d:	66 89 c2             	mov    %ax,%dx
            "movw %%bx, %%es\n\t"

    :
    :"r"(c)
    :"%eax", "ebx"
    );
    9170:	88 d0                	mov    %dl,%al
    9172:	b4 01                	mov    $0x1,%ah
    9174:	8c d3                	mov    %ss,%ebx
    9176:	8e e3                	mov    %ebx,%fs
    9178:	bb 00 00 8e d3       	mov    $0xd38e0000,%ebx
    917d:	8e db                	mov    %ebx,%ds
    917f:	8e c3                	mov    %ebx,%es
    9181:	cd 98                	int    $0x98
    9183:	8c e3                	mov    %fs,%ebx
    9185:	8e d3                	mov    %ebx,%ss
    9187:	8e db                	mov    %ebx,%ds
    9189:	8e c3                	mov    %ebx,%es
    //TODO
}
    918b:	66 5b                	pop    %bx
    918d:	66 5d                	pop    %bp
    918f:	66 c3                	retw   

00009191 <_Z7putchari>:
namespace hhlibc {

#endif
#ifndef _HHOS_LIBC_TEST
int putchar( int ch )
{
    9191:	66 55                	push   %bp
    9193:	66 89 e5             	mov    %sp,%bp
    9196:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    //sys_get_current_tty()->putchar(ch);
    system_call_putchar(ch);
    919b:	66 89 c8             	mov    %cx,%ax
    919e:	66 e8 c2 ff          	callw  9164 <_Z4atolPKc+0x18>
    91a2:	ff                   	(bad)  
    91a3:	ff 66 89             	jmp    *-0x77(%esi)
    //sys_tty_putchar(ch);
    return ch;
}
    91a6:	c8 66 5d 66          	enter  $0x5d66,$0x66
    91aa:	c3                   	ret    

000091ab <_Z4putsPKc>:

int puts(const char* string)
{
    91ab:	66 55                	push   %bp
    91ad:	66 89 e5             	mov    %sp,%bp
    91b0:	66 53                	push   %bx
    91b2:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    auto len = strlen(string);
    91b7:	66 53                	push   %bx
    91b9:	66 e8 1e f9          	callw  8adb <_Z6memsetPvim+0x23>
    91bd:	ff                   	(bad)  
    91be:	ff 66 89             	jmp    *-0x77(%esi)
    91c1:	d9 67 66             	fldenv 0x66(%edi)
    91c4:	8d 1c 03             	lea    (%ebx,%eax,1),%ebx
    91c7:	66 58                	pop    %ax
    for(size_t i = 0; i < len; ++i)
    91c9:	66 39 d9             	cmp    %bx,%cx
    91cc:	74 0f                	je     91dd <_Z4putsPKc+0x32>
    {
        putchar(*(string + i));
    91ce:	67 66 0f be 01       	movsbw (%bx,%di),%ax
    system_call_putchar(ch);
    91d3:	66 e8 8d ff          	callw  9164 <_Z4atolPKc+0x18>
    91d7:	ff                   	(bad)  
    91d8:	ff 66 41             	jmp    *0x41(%esi)
    for(size_t i = 0; i < len; ++i)
    91db:	eb ec                	jmp    91c9 <_Z4putsPKc+0x1e>
    }
    return 0;
}
    91dd:	66 31 c0             	xor    %ax,%ax
    91e0:	67 66 8b 5d fc       	mov    -0x4(%di),%bx
    91e5:	66 c9                	leavew 
    91e7:	66 c3                	retw   

000091e9 <_Z7getcharv>:
#endif


#ifndef _HHOS_LIBC_TEST
int getchar(void)
{
    91e9:	66 55                	push   %bp
    91eb:	66 89 e5             	mov    %sp,%bp
    );
    91ee:	b4 00                	mov    $0x0,%ah
    91f0:	cd 98                	int    $0x98
    91f2:	66 89 c2             	mov    %ax,%dx
    ret = ret & mask;
    91f5:	66 0f b6 c2          	movzbw %dl,%ax
    return system_call_getchar();
}
    91f9:	66 5d                	pop    %bp
    91fb:	66 c3                	retw   

000091fd <_Z4getsPc>:
char *gets( char *str )
{
    91fd:	66 55                	push   %bp
    91ff:	66 89 e5             	mov    %sp,%bp
    9202:	66 53                	push   %bx
    9204:	66 51                	push   %cx
    9206:	67 66 8b 4d 08       	mov    0x8(%di),%cx
    );
    920b:	b4 00                	mov    $0x0,%ah
    920d:	cd 98                	int    $0x98
    920f:	66 89 c3             	mov    %ax,%bx
    int cnt = 0;
    char ch;
    while(true)
    {
        ch = getchar();
        if (ch == '\b')
    9212:	80 fb 08             	cmp    $0x8,%bl
    9215:	74 f4                	je     920b <_Z4getsPc+0xe>
        {
            if (cnt > 0)
                putchar(ch);
            continue;
        }
        putchar(ch);
    9217:	66 0f be c3          	movsbw %bl,%ax
    921b:	67 88 5d fb          	mov    %bl,-0x5(%di)
    system_call_putchar(ch);
    921f:	66 e8 41 ff          	callw  9164 <_Z4atolPKc+0x18>
    9223:	ff                   	(bad)  
    9224:	ff 67 8a             	jmp    *-0x76(%edi)
        if(ch == 13) {
    9227:	55                   	push   %ebp
    9228:	fb                   	sti    
    9229:	80 fa 0d             	cmp    $0xd,%dl
    922c:	74 08                	je     9236 <_Z4getsPc+0x39>
            putchar('\n');
            break;
        }
        *(str++) = ch;
    922e:	66 41                	inc    %cx
    9230:	67 88 59 ff          	mov    %bl,-0x1(%bx,%di)
    9234:	eb d5                	jmp    920b <_Z4getsPc+0xe>
    system_call_putchar(ch);
    9236:	66 b8 0a 00          	mov    $0xa,%ax
    923a:	00 00                	add    %al,(%eax)
    923c:	66 e8 24 ff          	callw  9164 <_Z4atolPKc+0x18>
    9240:	ff                   	(bad)  
    9241:	ff 67 c6             	jmp    *-0x3a(%edi)
    }
    *str = '\0';
    9244:	01 00                	add    %eax,(%eax)
    return str;
}
    9246:	66 89 c8             	mov    %cx,%ax
    9249:	66 5a                	pop    %dx
    924b:	66 5b                	pop    %bx
    924d:	66 5d                	pop    %bp
    924f:	66 c3                	retw   

00009251 <_Z7vsscanfPKcS0_Pc>:
#endif

int vsscanf( const char* buffer, const char* format, va_list vlist )
{
    9251:	66 55                	push   %bp
    9253:	66 89 e5             	mov    %sp,%bp
    9256:	66 57                	push   %di
    9258:	66 56                	push   %si
    925a:	66 53                	push   %bx
    925c:	66 83 ec 14          	sub    $0x14,%sp
    9260:	67 66 8b 75 08       	mov    0x8(%di),%si
    9265:	67 66 8b 7d 10       	mov    0x10(%di),%di
    auto len_fmt = strlen(format);
    926a:	67 66 ff 75 0c       	pushw  0xc(%di)
    926f:	66 e8 68 f8          	callw  8adb <_Z6memsetPvim+0x23>
    9273:	ff                   	(bad)  
    9274:	ff 67 66             	jmp    *0x66(%edi)
    9277:	89 45 e0             	mov    %eax,-0x20(%ebp)
    927a:	66 59                	pop    %cx
    auto p_fmt = format; 
    927c:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    9281:	67 66 89 45 e8       	mov    %ax,-0x18(%di)
    auto p_buf = buffer;
    bool error = false;
    int ret = 0;
    9286:	67 66 c7 45 ec 00 00 	movw   $0x0,-0x14(%di)
    928d:	00 00                	add    %al,(%eax)
    bool error = false;
    928f:	67 c6 45 e7 00       	movb   $0x0,-0x19(%di)
    while(static_cast<size_t>(p_fmt - format) < len_fmt)
    9294:	67 66 8b 45 e8       	mov    -0x18(%di),%ax
    9299:	67 66 2b 45 0c       	sub    0xc(%di),%ax
    929e:	67 66 3b 45 e0       	cmp    -0x20(%di),%ax
    92a3:	0f 93 c0             	setae  %al
    {
        if(error) break;
    92a6:	67 08 45 e7          	or     %al,-0x19(%di)
    92aa:	0f 85 50 01 67 66    	jne    66679400 <_GLOBAL_OFFSET_TABLE_+0x6666d618>
        if(isspace(*p_fmt)) //略过白空格
    92b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    92b3:	67 66 0f be 00       	movsbw (%bx,%si),%ax
    92b8:	66 50                	push   %ax
    92ba:	66 e8 34 f9          	callw  8bf2 <_Z7reversePc+0x4a>
    92be:	ff                   	(bad)  
    92bf:	ff 66 5a             	jmp    *0x5a(%esi)
    92c2:	66 85 c0             	test   %ax,%ax
    92c5:	74 1d                	je     92e4 <_Z7vsscanfPKcS0_Pc+0x93>
        {
            p_fmt++;
    92c7:	67 66 ff 45 e8       	incw   -0x18(%di)
            while(isspace(*buffer)) buffer++;
    92cc:	67 66 0f be 06 66 50 	movsbw 0x5066,%ax
    92d3:	66 e8 1b f9          	callw  8bf2 <_Z7reversePc+0x4a>
    92d7:	ff                   	(bad)  
    92d8:	ff 66 5b             	jmp    *0x5b(%esi)
    92db:	66 85 c0             	test   %ax,%ax
    92de:	74 b4                	je     9294 <_Z7vsscanfPKcS0_Pc+0x43>
    92e0:	66 46                	inc    %si
    92e2:	eb e8                	jmp    92cc <_Z7vsscanfPKcS0_Pc+0x7b>
            continue;
        }
        else if(*p_fmt == '%') //格式控制符
    92e4:	67 66 8b 45 e8       	mov    -0x18(%di),%ax
    92e9:	67 80 38 25          	cmpb   $0x25,(%bx,%si)
    92ed:	75 a5                	jne    9294 <_Z7vsscanfPKcS0_Pc+0x43>
        {
            p_fmt++;
            char specifier = *p_fmt;
    92ef:	67 8a 40 01          	mov    0x1(%bx,%si),%al
            p_fmt++;
    92f3:	67 66 83 45 e8 02    	addw   $0x2,-0x18(%di)
            switch(specifier)
    92f9:	3c 69                	cmp    $0x69,%al
    92fb:	0f 84 b0 00 7f 25    	je     257f93b1 <_GLOBAL_OFFSET_TABLE_+0x257ed5c9>
    9301:	3c 58                	cmp    $0x58,%al
    9303:	0f 84 c4 00 7f 10    	je     107f93cd <_GLOBAL_OFFSET_TABLE_+0x107ed5e5>
    9309:	3c 25                	cmp    $0x25,%al
    930b:	75 87                	jne    9294 <_Z7vsscanfPKcS0_Pc+0x43>
            {
                case '%':
                {
                    if(*buffer == '%') 
    930d:	67 80 3e 25 67 0f    	cmpb   $0xf,0x6725
    9313:	95                   	xchg   %eax,%ebp
    9314:	45                   	inc    %ebp
    9315:	e7 e9                	out    %eax,$0xe9
    9317:	7b ff                	jnp    9318 <_Z7vsscanfPKcS0_Pc+0xc7>
            switch(specifier)
    9319:	3c 63                	cmp    $0x63,%al
    931b:	74 31                	je     934e <_Z7vsscanfPKcS0_Pc+0xfd>
    931d:	3c 64                	cmp    $0x64,%al
    931f:	0f 84 9a 00 e9 6e    	je     6ee993bf <_GLOBAL_OFFSET_TABLE_+0x6ee8d5d7>
    9325:	ff                   	(bad)  
    9326:	3c 73                	cmp    $0x73,%al
    9328:	74 4d                	je     9377 <_Z7vsscanfPKcS0_Pc+0x126>
    932a:	7f 15                	jg     9341 <_Z7vsscanfPKcS0_Pc+0xf0>
    932c:	3c 6f                	cmp    $0x6f,%al
    932e:	0f 85 62 ff 67 66    	jne    66689296 <_GLOBAL_OFFSET_TABLE_+0x6667d4ae>
                    ++ret;
                    break;
                }
                case 'o':
                {
                    unsigned int* p = va_arg(vlist, unsigned int*);
    9334:	8d 5f 04             	lea    0x4(%edi),%ebx
    9337:	67 66 8b 3f          	mov    (%bx),%di
                    char* end;
                    long num = strtol(buffer, &end, 8);
    933b:	66 6a 08             	pushw  $0x8
    933e:	e9 96 00 3c 75       	jmp    753c93d9 <_GLOBAL_OFFSET_TABLE_+0x753bd5f1>
            switch(specifier)
    9343:	74 78                	je     93bd <_Z7vsscanfPKcS0_Pc+0x16c>
    9345:	3c 78                	cmp    $0x78,%al
    9347:	0f 84 80 00 e9 46    	je     46e993cd <_GLOBAL_OFFSET_TABLE_+0x46e8d5e5>
    934d:	ff 67 66             	jmp    *0x66(%edi)
                    char* p = va_arg(vlist, char*);
    9350:	8b 17                	mov    (%edi),%edx
                    *p = *buffer;
    9352:	67 8a 06 67 88       	mov    -0x7799,%al
    9357:	02 66 46             	add    0x46(%esi),%ah
                    ++ret;
    935a:	67 66 ff 45 ec       	incw   -0x14(%di)
                    char* p = va_arg(vlist, char*);
    935f:	66 83 c7 04          	add    $0x4,%di
                    break;
    9363:	e9 2e ff 66 50       	jmp    50679296 <_GLOBAL_OFFSET_TABLE_+0x5066d4ae>
                    while (*buffer && isspace(*buffer)) buffer++;
    9368:	66 e8 86 f8          	callw  8bf2 <_Z7reversePc+0x4a>
    936c:	ff                   	(bad)  
    936d:	ff 66 59             	jmp    *0x59(%esi)
    9370:	66 85 c0             	test   %ax,%ax
    9373:	74 0b                	je     9380 <_Z7vsscanfPKcS0_Pc+0x12f>
    9375:	66 46                	inc    %si
    9377:	67 66 0f be 06 84 c0 	movsbw -0x3f7c,%ax
    937e:	75 e6                	jne    9366 <_Z7vsscanfPKcS0_Pc+0x115>
                    char* p = va_arg(vlist, char*);
    9380:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    9385:	67 66 8b 3f          	mov    (%bx),%di
                    while(*buffer && !isspace(*buffer))
    9389:	67 66 0f be 06 84 c0 	movsbw -0x3f7c,%ax
    9390:	75 0b                	jne    939d <_Z7vsscanfPKcS0_Pc+0x14c>
                    *p = '\0';
    9392:	67 c6 07 00          	movb   $0x0,(%bx)
                    ++ret;
    9396:	67 66 ff 45 ec       	incw   -0x14(%di)
    939b:	eb 5b                	jmp    93f8 <_Z7vsscanfPKcS0_Pc+0x1a7>
                    while(*buffer && !isspace(*buffer))
    939d:	66 50                	push   %ax
    939f:	66 e8 4f f8          	callw  8bf2 <_Z7reversePc+0x4a>
    93a3:	ff                   	(bad)  
    93a4:	ff 66 5a             	jmp    *0x5a(%esi)
    93a7:	66 85 c0             	test   %ax,%ax
    93aa:	75 e6                	jne    9392 <_Z7vsscanfPKcS0_Pc+0x141>
                        *(p++) = *(buffer++);
    93ac:	a4                   	movsb  %ds:(%esi),%es:(%edi)
                    while(*buffer && !isspace(*buffer))
    93ad:	eb da                	jmp    9389 <_Z7vsscanfPKcS0_Pc+0x138>
                    int* p = va_arg(vlist, int*);
    93af:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    93b4:	67 66 8b 3f          	mov    (%bx),%di
                    long num = strtol(buffer, &end, 0);
    93b8:	66 6a 00             	pushw  $0x0
    93bb:	eb 1a                	jmp    93d7 <_Z7vsscanfPKcS0_Pc+0x186>
                    unsigned int* p = va_arg(vlist, unsigned int*);
    93bd:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    93c2:	67 66 8b 3f          	mov    (%bx),%di
                    long num = strtol(buffer, &end, 10);
    93c6:	66 6a 0a             	pushw  $0xa
    93c9:	eb 0c                	jmp    93d7 <_Z7vsscanfPKcS0_Pc+0x186>
                    break;
                }
                case 'x':
                case 'X':
                {
                    unsigned int* p = va_arg(vlist, unsigned int*);
    93cb:	67 66 8d 5f 04       	lea    0x4(%bx),%bx
    93d0:	67 66 8b 3f          	mov    (%bx),%di
                    char* end;
                    long num = strtol(buffer, &end, 16);
    93d4:	66 6a 10             	pushw  $0x10
    93d7:	67 66 8d 45 f0       	lea    -0x10(%di),%ax
    93dc:	66 50                	push   %ax
    93de:	66 56                	push   %si
    93e0:	66 e8 a3 fb          	callw  8f87 <_Z4ldivll+0xa9>
    93e4:	ff                   	(bad)  
    93e5:	ff 67 66             	jmp    *0x66(%edi)
                    *p = static_cast<unsigned int>(num);
    93e8:	89 07                	mov    %eax,(%edi)
                    buffer = end;
    93ea:	67 66 8b 75 f0       	mov    -0x10(%di),%si
                    ++ret;
    93ef:	67 66 ff 45 ec       	incw   -0x14(%di)
    93f4:	66 83 c4 0c          	add    $0xc,%sp
                    unsigned int* p = va_arg(vlist, unsigned int*);
    93f8:	66 89 df             	mov    %bx,%di
    93fb:	e9 96 fe 67 66       	jmp    66689296 <_GLOBAL_OFFSET_TABLE_+0x6667d4ae>
                    break;
            }
        }
    }
    return ret;
}
    9400:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9403:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    9408:	66 5b                	pop    %bx
    940a:	66 5e                	pop    %si
    940c:	66 5f                	pop    %di
    940e:	66 5d                	pop    %bp
    9410:	66 c3                	retw   

00009412 <_Z6sscanfPKcS0_z>:
int sscanf( const char* buffer, const char* format, ... )
{
    9412:	66 55                	push   %bp
    9414:	66 89 e5             	mov    %sp,%bp
   	int ret;
	va_list va;
	va_start(va, format);
    9417:	67 66 8d 45 10       	lea    0x10(%di),%ax
	ret = vsscanf(buffer, format, va);
    941c:	66 50                	push   %ax
    941e:	67 66 ff 75 0c       	pushw  0xc(%di)
    9423:	67 66 ff 75 08       	pushw  0x8(%di)
    9428:	66 e8 23 fe          	callw  924f <_Z4getsPc+0x52>
    942c:	ff                   	(bad)  
    942d:	ff 66 c9             	jmp    *-0x37(%esi)
	va_end(va);
    return ret; 
}
    9430:	66 c3                	retw   

00009432 <_Z5scanfPKcz>:
#ifndef _HHOS_LIBC_TEST
static char scanfbuf[80*25];
//TODO 关于这个返回值
int scanf( const char* format, ... )
{
    9432:	66 55                	push   %bp
    9434:	66 89 e5             	mov    %sp,%bp
    if (!gets(scanfbuf)) return EOF;
    9437:	66 68 60 aa          	pushw  $0xaa60
    943b:	00 00                	add    %al,(%eax)
    943d:	66 e8 ba fd          	callw  91fb <_Z7getcharv+0x12>
    9441:	ff                   	(bad)  
    9442:	ff 66 89             	jmp    *-0x77(%esi)
    9445:	c2 66 58             	ret    $0x5866
    9448:	66 83 c8 ff          	or     $0xffff,%ax
    944c:	66 85 d2             	test   %dx,%dx
    944f:	74 1c                	je     946d <_Z5scanfPKcz+0x3b>
	int ret;
	va_list va;
	va_start(va, format);
    9451:	67 66 8d 45 0c       	lea    0xc(%di),%ax
	ret = vsscanf(scanfbuf, format, va);
    9456:	66 50                	push   %ax
    9458:	67 66 ff 75 08       	pushw  0x8(%di)
    945d:	66 68 60 aa          	pushw  $0xaa60
    9461:	00 00                	add    %al,(%eax)
    9463:	66 e8 e8 fd          	callw  924f <_Z4getsPc+0x52>
    9467:	ff                   	(bad)  
    9468:	ff 66 83             	jmp    *-0x7d(%esi)
	va_end(va);
    return ret;
    946b:	c4 0c 66             	les    (%esi,%eiz,2),%ecx
}
    946e:	c9                   	leave  
    946f:	66 c3                	retw   

00009471 <_Z8vsprintfPcPKcS_>:
{
    9471:	66 55                	push   %bp
    9473:	66 89 e5             	mov    %sp,%bp
    9476:	66 57                	push   %di
    9478:	66 56                	push   %si
    947a:	66 53                	push   %bx
    947c:	66 83 ec 0c          	sub    $0xc,%sp
    9480:	67 66 8b 75 0c       	mov    0xc(%di),%si
    9485:	67 66 8b 55 10       	mov    0x10(%di),%dx
    948a:	67 66 89 55 f0       	mov    %dx,-0x10(%di)
    auto len_fmt = strlen(format);
    948f:	66 56                	push   %si
    9491:	66 e8 46 f6          	callw  8adb <_Z6memsetPvim+0x23>
    9495:	ff                   	(bad)  
    9496:	ff 67 66             	jmp    *0x66(%edi)
    9499:	89 45 ec             	mov    %eax,-0x14(%ebp)
    949c:	66 58                	pop    %ax
    auto p_buf = buffer;
    949e:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    94a3:	67 66 8b 55 f0       	mov    -0x10(%di),%dx
    while(len_fmt--)
    94a8:	67 66 ff 4d ec       	decw   -0x14(%di)
    94ad:	67 66 83 7d ec ff    	cmpw   $0xffff,-0x14(%di)
    94b3:	0f 84 4a 01 67 8a    	je     8a679603 <_GLOBAL_OFFSET_TABLE_+0x8a66d81b>
        if(*p_fmt != '%')
    94b9:	06                   	push   %es
    94ba:	3c 25                	cmp    $0x25,%al
    94bc:	74 07                	je     94c5 <_Z8vsprintfPcPKcS_+0x54>
            *(p_buf++) = *(p_fmt++);    //非控制字符
    94be:	66 46                	inc    %si
    94c0:	67 88 03             	mov    %al,(%bp,%di)
    94c3:	eb 5f                	jmp    9524 <_Z8vsprintfPcPKcS_+0xb3>
            char specifier = *(++p_fmt); //%后面一个字符是specifier
    94c5:	67 8a 46 01          	mov    0x1(%bp),%al
            ++p_fmt;                     //记录specifier并跳过
    94c9:	66 83 c6 02          	add    $0x2,%si
            switch (specifier)
    94cd:	3c 69                	cmp    $0x69,%al
    94cf:	0f 84 81 00 7f 17    	je     177f9556 <_GLOBAL_OFFSET_TABLE_+0x177ed76e>
    94d5:	3c 63                	cmp    $0x63,%al
    94d7:	74 40                	je     9519 <_Z8vsprintfPcPKcS_+0xa8>
    94d9:	3c 64                	cmp    $0x64,%al
    94db:	74 77                	je     9554 <_Z8vsprintfPcPKcS_+0xe3>
    94dd:	3c 58                	cmp    $0x58,%al
    94df:	75 c7                	jne    94a8 <_Z8vsprintfPcPKcS_+0x37>
                    unsigned int num = va_arg(vlist, int);
    94e1:	67 66 8d 7a 04       	lea    0x4(%bp,%si),%di
                    itoa(p_buf, num, 16, true);
    94e6:	66 6a 01             	pushw  $0x1
    94e9:	e9 e2 00 3c 73       	jmp    733c95d0 <_GLOBAL_OFFSET_TABLE_+0x733bd7e8>
            switch (specifier)
    94ee:	74 38                	je     9528 <_Z8vsprintfPcPKcS_+0xb7>
    94f0:	7f 12                	jg     9504 <_Z8vsprintfPcPKcS_+0x93>
    94f2:	3c 6f                	cmp    $0x6f,%al
    94f4:	75 b2                	jne    94a8 <_Z8vsprintfPcPKcS_+0x37>
                    unsigned int num = va_arg(vlist, int);
    94f6:	67 66 8d 7a 04       	lea    0x4(%bp,%si),%di
                    itoa(p_buf, num, 8);
    94fb:	66 6a 00             	pushw  $0x0
    94fe:	66 6a 08             	pushw  $0x8
    9501:	e9 da 00 3c 75       	jmp    753c95e0 <_GLOBAL_OFFSET_TABLE_+0x753bd7f8>
            switch (specifier)
    9506:	0f 84 c9 00 3c 78    	je     783c95d5 <_GLOBAL_OFFSET_TABLE_+0x783bd7ed>
    950c:	75 9a                	jne    94a8 <_Z8vsprintfPcPKcS_+0x37>
                    unsigned int num = va_arg(vlist, int);
    950e:	67 66 8d 7a 04       	lea    0x4(%bp,%si),%di
                    itoa(p_buf, num, 16);
    9513:	66 6a 00             	pushw  $0x0
    9516:	e9 b5 00 67 66       	jmp    666795d0 <_GLOBAL_OFFSET_TABLE_+0x6666d7e8>
                    *(p_buf++) = va_arg(vlist, int); 
    951b:	8b 02                	mov    (%edx),%eax
    951d:	67 88 03             	mov    %al,(%bp,%di)
    9520:	66 83 c2 04          	add    $0x4,%dx
    9524:	66 43                	inc    %bx
                    break;
    9526:	eb 80                	jmp    94a8 <_Z8vsprintfPcPKcS_+0x37>
                    const char * str = va_arg(vlist, char*);
    9528:	67 66 8d 42 04       	lea    0x4(%bp,%si),%ax
    952d:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
    9532:	67 66 8b 3a          	mov    (%bp,%si),%di
                    strcpy(p_buf, str);
    9536:	66 57                	push   %di
    9538:	66 53                	push   %bx
    953a:	66 e8 b9 f5          	callw  8af7 <_Z6strlenPKc+0x1a>
    953e:	ff                   	(bad)  
    953f:	ff 66 59             	jmp    *0x59(%esi)
                    p_buf += strlen(str);               //p应当永远指向有意义的字符后面一位
    9542:	66 58                	pop    %ax
    9544:	66 57                	push   %di
    9546:	66 e8 91 f5          	callw  8adb <_Z6memsetPvim+0x23>
    954a:	ff                   	(bad)  
    954b:	ff 66 01             	jmp    *0x1(%esi)
    954e:	c3                   	ret    
                    break;
    954f:	66 58                	pop    %ax
    9551:	e9 4f ff 67 66       	jmp    666894a5 <_GLOBAL_OFFSET_TABLE_+0x6667d6bd>
                    int num = va_arg(vlist, int);
    9556:	8d 42 04             	lea    0x4(%edx),%eax
    9559:	67 66 89 45 e8       	mov    %ax,-0x18(%di)
    955e:	67 66 8b 02          	mov    (%bp,%si),%ax
template<typename T>
void itoa(char* buffer, T num, int base, bool captial = false)
{
    const char* num_char_upper = "0123456789ABCDEF";
    const char* num_char_lower = "0123456789abcdef";
    if(num < 0)
    9562:	66 89 df             	mov    %bx,%di
    9565:	66 85 c0             	test   %ax,%ax
    9568:	79 0c                	jns    9576 <_Z8vsprintfPcPKcS_+0x105>
    956a:	67 66 8d 7b 01       	lea    0x1(%bp,%di),%di
    {
        *(buffer++) = '-';
    956f:	67 c6 03 2d          	movb   $0x2d,(%bp,%di)
        num = -num;
    9573:	66 f7 d8             	neg    %ax
    }
    char *p = buffer;
    9576:	67 66 89 7d f0       	mov    %di,-0x10(%di)
    int mod = 0;
    while(true)
    {
        mod = num % base;
        num /= base;
    957b:	66 b9 0a 00          	mov    $0xa,%cx
    957f:	00 00                	add    %al,(%eax)
    9581:	66 99                	cwtd   
    9583:	66 f7 f9             	idiv   %cx
        *(p++) = captial ? num_char_upper[mod] : num_char_lower[mod];
    9586:	67 66 8b 4d f0       	mov    -0x10(%di),%cx
    958b:	66 41                	inc    %cx
    958d:	67 8a 92 d5 bd       	mov    -0x422b(%bp,%si),%dl
    9592:	00 00                	add    %al,(%eax)
    9594:	67 88 51 ff          	mov    %dl,-0x1(%bx,%di)
        if(num == 0) break;
    9598:	66 85 c0             	test   %ax,%ax
    959b:	74 07                	je     95a4 <_Z8vsprintfPcPKcS_+0x133>
    959d:	67 66 89 4d f0       	mov    %cx,-0x10(%di)
    95a2:	eb d7                	jmp    957b <_Z8vsprintfPcPKcS_+0x10a>
    }
    *p = '\0';
    95a4:	67 66 8b 45 f0       	mov    -0x10(%di),%ax
    95a9:	67 c6 40 01 00       	movb   $0x0,0x1(%bx,%si)
    reverse(buffer);
    95ae:	66 57                	push   %di
    95b0:	66 e8 f2 f5          	callw  8ba6 <_Z6strcmpPKcS0_+0x6b>
    95b4:	ff                   	(bad)  
    95b5:	ff 67 66             	jmp    *0x66(%edi)
                    p_buf += strlen(p_buf);             //同理
    95b8:	89 1c 24             	mov    %ebx,(%esp)
    95bb:	66 e8 1c f5          	callw  8adb <_Z6memsetPvim+0x23>
    95bf:	ff                   	(bad)  
    95c0:	ff 66 01             	jmp    *0x1(%esi)
    95c3:	c3                   	ret    
                    break;
    95c4:	66 5a                	pop    %dx
                    int num = va_arg(vlist, int);
    95c6:	67 66 8b 55 e8       	mov    -0x18(%di),%dx
                    break;
    95cb:	e9 da fe 66 6a       	jmp    6a6794aa <_GLOBAL_OFFSET_TABLE_+0x6a66d6c2>
                    itoa(p_buf, num, 16, true);
    95d0:	10 eb                	adc    %ch,%bl
    95d2:	0b 67 66             	or     0x66(%edi),%esp
                    unsigned int num = va_arg(vlist, int);
    95d5:	8d 7a 04             	lea    0x4(%edx),%edi
                    itoa(p_buf, num, 10);
    95d8:	66 6a 00             	pushw  $0x0
    95db:	66 6a 0a             	pushw  $0xa
    95de:	67 66 ff 32          	pushw  (%bp,%si)
    95e2:	66 53                	push   %bx
    95e4:	66 e8 d2 09          	callw  9fba <_ZN2sh3runEv+0x372>
    95e8:	00 00                	add    %al,(%eax)
                    p_buf += strlen(p_buf);             //同理
    95ea:	66 83 c4 10          	add    $0x10,%sp
    95ee:	66 53                	push   %bx
    95f0:	66 e8 e7 f4          	callw  8adb <_Z6memsetPvim+0x23>
    95f4:	ff                   	(bad)  
    95f5:	ff 66 01             	jmp    *0x1(%esi)
    95f8:	c3                   	ret    
                    break;
    95f9:	66 58                	pop    %ax
                    unsigned int num = va_arg(vlist, int);
    95fb:	66 89 fa             	mov    %di,%dx
                    break;
    95fe:	e9 a7 fe 67 c6       	jmp    c66894aa <_GLOBAL_OFFSET_TABLE_+0xc667d6c2>
    *p_buf = '\0';
    9603:	03 00                	add    (%eax),%eax
    return p_buf - buffer;
    9605:	66 89 d8             	mov    %bx,%ax
    9608:	67 66 2b 45 08       	sub    0x8(%di),%ax
}
    960d:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    9612:	66 5b                	pop    %bx
    9614:	66 5e                	pop    %si
    9616:	66 5f                	pop    %di
    9618:	66 5d                	pop    %bp
    961a:	66 c3                	retw   

0000961c <_Z7sprintfPcPKcz>:
{
    961c:	66 55                	push   %bp
    961e:	66 89 e5             	mov    %sp,%bp
	va_start(va, format);
    9621:	67 66 8d 45 10       	lea    0x10(%di),%ax
	ret = vsprintf(buffer, format, va);
    9626:	66 50                	push   %ax
    9628:	67 66 ff 75 0c       	pushw  0xc(%di)
    962d:	67 66 ff 75 08       	pushw  0x8(%di)
    9632:	66 e8 39 fe          	callw  946f <_Z5scanfPKcz+0x3d>
    9636:	ff                   	(bad)  
    9637:	ff 66 c9             	jmp    *-0x37(%esi)
}
    963a:	66 c3                	retw   

0000963c <_Z6printfPKcz>:
{
    963c:	66 55                	push   %bp
    963e:	66 89 e5             	mov    %sp,%bp
    9641:	66 53                	push   %bx
	va_start(va, format);
    9643:	67 66 8d 45 0c       	lea    0xc(%di),%ax
	ret = vsprintf(printbuf, format, va);
    9648:	66 50                	push   %ax
    964a:	67 66 ff 75 08       	pushw  0x8(%di)
    964f:	66 68 40 b2          	pushw  $0xb240
    9653:	00 00                	add    %al,(%eax)
    9655:	66 e8 16 fe          	callw  946f <_Z5scanfPKcz+0x3d>
    9659:	ff                   	(bad)  
    965a:	ff 66 89             	jmp    *-0x77(%esi)
    965d:	c3                   	ret    
    puts(printbuf);
    965e:	66 83 c4 0c          	add    $0xc,%sp
    9662:	66 68 40 b2          	pushw  $0xb240
    9666:	00 00                	add    %al,(%eax)
    9668:	66 e8 3d fb          	callw  91a9 <_Z7putchari+0x18>
    966c:	ff                   	(bad)  
    966d:	ff 66 89             	jmp    *-0x77(%esi)
}
    9670:	d8 67 66             	fsubs  0x66(%edi)
    9673:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9676:	66 c9                	leavew 
    9678:	66 c3                	retw   

Disassembly of section .text._ZN2sh2bfEPKcS1_.isra.4:

0000967a <_ZN2sh2bfEPKcS1_.isra.4>:
    int bf(const char* Pattern, const char * Text) {
    967a:	66 55                	push   %bp
    967c:	66 89 e5             	mov    %sp,%bp
    967f:	66 57                	push   %di
    9681:	66 56                	push   %si
    9683:	66 53                	push   %bx
    9685:	66 51                	push   %cx
    9687:	66 89 c3             	mov    %ax,%bx
    968a:	66 89 d7             	mov    %dx,%di
        ss_t m = strlen(Pattern);
    968d:	66 50                	push   %ax
    968f:	66 e8 48 f4          	callw  8adb <_Z6memsetPvim+0x23>
    9693:	ff                   	(bad)  
    9694:	ff 66 89             	jmp    *-0x77(%esi)
    9697:	c6                   	(bad)  
        ss_t n = strlen(Text);
    9698:	67 66 89 3c          	mov    %di,(%si)
    969c:	24 66                	and    $0x66,%al
    969e:	e8 3a f4 ff ff       	call   8add <_Z6strlenPKc>
    96a3:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
    96a8:	66 58                	pop    %ax
        ss_t i = 0, k = 0;
    96aa:	66 31 d2             	xor    %dx,%dx
    96ad:	66 31 c9             	xor    %cx,%cx
        while(k < m && i < n) {
    96b0:	66 39 d6             	cmp    %dx,%si
    96b3:	7e 21                	jle    96d6 <_ZN2sh2bfEPKcS1_.isra.4+0x5c>
    96b5:	67 66 39 4d f0       	cmp    %cx,-0x10(%di)
    96ba:	7e 22                	jle    96de <_ZN2sh2bfEPKcS1_.isra.4+0x64>
            if(Pattern[k] == Text[i]) {
    96bc:	67 8a 04             	mov    (%si),%al
    96bf:	0f 67 38             	packuswb (%eax),%mm7
    96c2:	04 13                	add    $0x13,%al
    96c4:	75 06                	jne    96cc <_ZN2sh2bfEPKcS1_.isra.4+0x52>
                ++k;
    96c6:	66 42                	inc    %dx
                ++i;
    96c8:	66 41                	inc    %cx
    96ca:	eb e4                	jmp    96b0 <_ZN2sh2bfEPKcS1_.isra.4+0x36>
                i = i - k + 1;
    96cc:	66 29 d1             	sub    %dx,%cx
    96cf:	66 41                	inc    %cx
                k = 0;
    96d1:	66 31 d2             	xor    %dx,%dx
    96d4:	eb da                	jmp    96b0 <_ZN2sh2bfEPKcS1_.isra.4+0x36>
            return i - k;
    96d6:	66 89 c8             	mov    %cx,%ax
    96d9:	66 29 d0             	sub    %dx,%ax
    96dc:	eb 04                	jmp    96e2 <_ZN2sh2bfEPKcS1_.isra.4+0x68>
        return -1;
    96de:	66 83 c8 ff          	or     $0xffff,%ax
    }
    96e2:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    96e7:	66 5b                	pop    %bx
    96e9:	66 5e                	pop    %si
    96eb:	66 5f                	pop    %di
    96ed:	66 5d                	pop    %bp
    96ef:	66 c3                	retw   

Disassembly of section .text._ZN3tty8tty_initEv:

000096f2 <_ZN3tty8tty_initEv>:
    void tty_init()
    96f2:	66 55                	push   %bp
    96f4:	66 89 e5             	mov    %sp,%bp
    96f7:	66 53                	push   %bx
    96f9:	67 66 8b 5d 08       	mov    0x8(%di),%bx
        cur_x = 0;
    96fe:	67 66 c7 03 00 00    	movw   $0x0,(%bp,%di)
    9704:	00 00                	add    %al,(%eax)
        cur_y = 0;
    9706:	67 66 c7 43 04 00 00 	movw   $0x0,0x4(%bp,%di)
    970d:	00 00                	add    %al,(%eax)
        move_cursor(0, 0);
    970f:	66 31 d2             	xor    %dx,%dx
    9712:	66 31 c0             	xor    %ax,%ax
    9715:	66 e8 01 e9          	callw  801a <_ZL8print_okPc+0x50>
    9719:	ff                   	(bad)  
    971a:	ff 67 66             	jmp    *0x66(%edi)
        color = MAKE_COLOR(VGA_BLACK, VGA_WHITE);
    971d:	c7 43 08 07 00 00 00 	movl   $0x7,0x8(%ebx)
    }
    9724:	66 5b                	pop    %bx
    9726:	66 5d                	pop    %bp
    9728:	66 c3                	retw   

Disassembly of section .text._ZN3tty7putcharEi:

0000972a <_ZN3tty7putcharEi>:
        tty_mem[y + 80 * x] = c;
        tty_mem[y + 80 * x + 1] = color;
#endif
        sys_putchar(c, color, x, y);
    }
    void putchar(int c)
    972a:	66 55                	push   %bp
    972c:	66 89 e5             	mov    %sp,%bp
    972f:	66 56                	push   %si
    9731:	66 53                	push   %bx
    9733:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    9738:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    {
        switch(c)
    973d:	66 83 f8 0d          	cmp    $0xd,%ax
    9741:	77 79                	ja     97bc <_ZN3tty7putcharEi+0x92>
    9743:	67 ff 24             	jmp    *(%si)
    9746:	85 78 ba             	test   %edi,-0x46(%eax)
    9749:	00 00                	add    %al,(%eax)
    974b:	66 be 04 00          	mov    $0x4,%si
    974f:	00 00                	add    %al,(%eax)
        {
            case '\t':
            {
                for(int i = 0; i < 4; ++i) putchar(' ');
    9751:	66 6a 20             	pushw  $0x20
    9754:	66 53                	push   %bx
    9756:	66 e8 ce ff          	callw  9728 <_ZN3tty8tty_initEv+0x36>
    975a:	ff                   	(bad)  
    975b:	ff 66 5a             	jmp    *0x5a(%esi)
    975e:	66 59                	pop    %cx
    9760:	66 4e                	dec    %si
    9762:	75 ed                	jne    9751 <_ZN3tty7putcharEi+0x27>
    9764:	e9 96 00 67 66       	jmp    666797ff <_GLOBAL_OFFSET_TABLE_+0x6666da17>
            }
            case 0:
                break;
            case '\b':
            {
                if(cur_y == 0 && cur_x == 0) 
    9769:	8b 53 04             	mov    0x4(%ebx),%edx
    976c:	67 66 8b 03          	mov    (%bp,%di),%ax
    9770:	66 85 d2             	test   %dx,%dx
    9773:	75 1b                	jne    9790 <_ZN3tty7putcharEi+0x66>
    9775:	66 85 c0             	test   %ax,%ax
    9778:	0f 84 99 00 67 66    	je     66679817 <_GLOBAL_OFFSET_TABLE_+0x6666da2f>
                {
                    break;
                }
                else if (cur_y == 0 && cur_x != 0)
                {
                    cur_y = 80 - 1;
    977e:	c7 43 04 4f 00 00 00 	movl   $0x4f,0x4(%ebx)
                    cur_x--;
    9785:	66 48                	dec    %ax
    9787:	67 66 89 03          	mov    %ax,(%bp,%di)
        sys_putchar(c, color, x, y);
    978b:	66 6a 4f             	pushw  $0x4f
    978e:	eb 09                	jmp    9799 <_ZN3tty7putcharEi+0x6f>
                    putchar_worker(' ', MAKE_COLOR(VGA_BLACK, VGA_WHITE) , cur_x, cur_y);
                    break;
                }
                else
                {
                    cur_y--;
    9790:	66 4a                	dec    %dx
    9792:	67 66 89 53 04       	mov    %dx,0x4(%bp,%di)
        sys_putchar(c, color, x, y);
    9797:	66 52                	push   %dx
    9799:	66 50                	push   %ax
    979b:	66 6a 07             	pushw  $0x7
    979e:	66 6a 20             	pushw  $0x20
    97a1:	66 e8 47 eb          	callw  82ec <sys_bios_print_int+0xa4>
    97a5:	ff                   	(bad)  
    97a6:	ff 66 83             	jmp    *-0x7d(%esi)
    97a9:	c4 10                	les    (%eax),%edx
    97ab:	eb 50                	jmp    97fd <_ZN3tty7putcharEi+0xd3>
                    break;
                }
            }
            case '\n':
            {
                cur_x++;
    97ad:	67 66 ff 03          	incw   (%bp,%di)
                cur_y = 0;
    97b1:	67 66 c7 43 04 00 00 	movw   $0x0,0x4(%bp,%di)
    97b8:	00 00                	add    %al,(%eax)
                break;
    97ba:	eb 41                	jmp    97fd <_ZN3tty7putcharEi+0xd3>
        sys_putchar(c, color, x, y);
    97bc:	67 66 ff 73 04       	pushw  0x4(%bp,%di)
    97c1:	67 66 ff 33          	pushw  (%bp,%di)
    97c5:	67 66 ff 73 08       	pushw  0x8(%bp,%di)
    97ca:	66 50                	push   %ax
    97cc:	66 e8 1c eb          	callw  82ec <sys_bios_print_int+0xa4>
    97d0:	ff                   	(bad)  
    97d1:	ff 67 66             	jmp    *0x66(%edi)
            }
            default:
            {
                putchar_worker(c, color, cur_x, cur_y);
                cur_x = (cur_y == 79) ? cur_x + 1 : cur_x;
    97d4:	8b 43 04             	mov    0x4(%ebx),%eax
    97d7:	66 83 c4 10          	add    $0x10,%sp
    97db:	66 83 f8 4f          	cmp    $0x4f,%ax
    97df:	67 66 8b 13          	mov    (%bp,%di),%dx
    97e3:	75 02                	jne    97e7 <_ZN3tty7putcharEi+0xbd>
    97e5:	66 42                	inc    %dx
    97e7:	67 66 89 13          	mov    %dx,(%bp,%di)
                cur_y = (cur_y + 1) % 80;
    97eb:	66 40                	inc    %ax
    97ed:	66 b9 50 00          	mov    $0x50,%cx
    97f1:	00 00                	add    %al,(%eax)
    97f3:	66 99                	cwtd   
    97f5:	66 f7 f9             	idiv   %cx
    97f8:	67 66 89 53 04       	mov    %dx,0x4(%bp,%di)
        if (cur_x >= 25)
    97fd:	67 66 83 3b 18       	cmpw   $0x18,(%bp,%di)
    9802:	7e 11                	jle    9815 <_ZN3tty7putcharEi+0xeb>
            sys_bios_scroll_up(color);
    9804:	67 66 ff 73 08       	pushw  0x8(%bp,%di)
    9809:	66 e8 10 ec          	callw  841d <sys_print_int+0xa4>
    980d:	ff                   	(bad)  
    980e:	ff 67 66             	jmp    *0x66(%edi)
            --cur_x;
    9811:	ff 0b                	decl   (%ebx)
    9813:	66 58                	pop    %ax
                break;
            }
        }
        scroll_up();
        move_cursor(cur_x, cur_y);
    9815:	67 66 8b 53 04       	mov    0x4(%bp,%di),%dx
    981a:	67 66 8b 03          	mov    (%bp,%di),%ax
    }
    981e:	67 66 8d 65 f8       	lea    -0x8(%di),%sp
    9823:	66 5b                	pop    %bx
    9825:	66 5e                	pop    %si
    9827:	66 5d                	pop    %bp
        move_cursor(cur_x, cur_y);
    9829:	e9                   	.byte 0xe9
    982a:	f0                   	lock
    982b:	e7                   	.byte 0xe7

Disassembly of section .text._ZN2sh4execERKNS_3cmdE:

0000982c <_ZN2sh4execERKNS_3cmdE>:
    int exec(const cmd & input_cmd)
    982c:	66 55                	push   %bp
    982e:	66 89 e5             	mov    %sp,%bp
    9831:	66 57                	push   %di
    9833:	66 56                	push   %si
    9835:	66 53                	push   %bx
    9837:	66 83 ec 08          	sub    $0x8,%sp
    983b:	67 66 8b 5d 08       	mov    0x8(%di),%bx
    9840:	67 66 8b 75 0c       	mov    0xc(%di),%si
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    9845:	66 68 f7 ba          	pushw  $0xbaf7
    9849:	00 00                	add    %al,(%eax)
    984b:	67 66 8b 06 67 66    	mov    0x6667,%ax
    9851:	ff 74 83 04          	pushl  0x4(%ebx,%eax,4)
    9855:	66 e8 e0 f2          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    9859:	ff                   	(bad)  
    985a:	ff 66 5a             	jmp    *0x5a(%esi)
        if (is_command(input_cmd, "ls") || is_command(input_cmd, "dir")) {
    985d:	66 59                	pop    %cx
    985f:	66 85 c0             	test   %ax,%ax
    9862:	75 33                	jne    9897 <_ZN2sh4execERKNS_3cmdE+0x6b>
            printf("You have %d user programs intalled\n", prog_cnt);
    9864:	67 66 ff b3 84 0b    	pushw  0xb84(%bp,%di)
    986a:	00 00                	add    %al,(%eax)
    986c:	66 68 b0 ba          	pushw  $0xbab0
    9870:	00 00                	add    %al,(%eax)
    9872:	66 e8 c4 fd          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9876:	ff                   	(bad)  
    9877:	ff 66 5e             	jmp    *0x5e(%esi)
            printf("Program Name\t\t\tSector Number\n");
    987a:	66 5f                	pop    %di
    987c:	66 68 d4 ba          	pushw  $0xbad4
    9880:	00 00                	add    %al,(%eax)
    9882:	66 e8 b4 fd          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9886:	ff                   	(bad)  
    9887:	ff 67 66             	jmp    *0x66(%edi)
    988a:	8d b3 8c 0b 00 00    	lea    0xb8c(%ebx),%esi
    9890:	66 58                	pop    %ax
            for (size_t i = 0; i < prog_cnt; ++i) {
    9892:	66 31 ff             	xor    %di,%di
    9895:	eb 41                	jmp    98d8 <_ZN2sh4execERKNS_3cmdE+0xac>
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    9897:	66 68 f2 ba          	pushw  $0xbaf2
    989b:	00 00                	add    %al,(%eax)
    989d:	67 66 8b 06 67 66    	mov    0x6667,%ax
    98a3:	ff 74 83 04          	pushl  0x4(%ebx,%eax,4)
    98a7:	66 e8 8e f2          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    98ab:	ff                   	(bad)  
    98ac:	ff 66 5a             	jmp    *0x5a(%esi)
        if (is_command(input_cmd, "ls") || is_command(input_cmd, "dir")) {
    98af:	66 59                	pop    %cx
    98b1:	66 85 c0             	test   %ax,%ax
    98b4:	74 ae                	je     9864 <_ZN2sh4execERKNS_3cmdE+0x38>
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    98b6:	66 68 f6 ba          	pushw  $0xbaf6
    98ba:	00 00                	add    %al,(%eax)
    98bc:	67 66 8b 06 67 66    	mov    0x6667,%ax
    98c2:	ff 74 83 04          	pushl  0x4(%ebx,%eax,4)
    98c6:	66 e8 6f f2          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    98ca:	ff                   	(bad)  
    98cb:	ff 66 59             	jmp    *0x59(%esi)
        else if (is_command(input_cmd, "cls") || is_command(input_cmd, "clear"))
    98ce:	66 5f                	pop    %di
    98d0:	66 85 c0             	test   %ax,%ax
    98d3:	75 2e                	jne    9903 <_ZN2sh4execERKNS_3cmdE+0xd7>
    98d5:	e9 dc 01 67 66       	jmp    66679ab6 <_GLOBAL_OFFSET_TABLE_+0x6666dcce>
            for (size_t i = 0; i < prog_cnt; ++i) {
    98da:	39 bb 84 0b 00 00    	cmp    %edi,0xb84(%ebx)
    98e0:	0f 86 14 02 67 66    	jbe    66679afa <_GLOBAL_OFFSET_TABLE_+0x6666dd12>
                printf("%s\t\t\t\t\t%d\n", progs[i].name, progs[i].lba);
    98e6:	ff 76 20             	pushl  0x20(%esi)
    98e9:	66 56                	push   %si
    98eb:	66 68 fa ba          	pushw  $0xbafa
    98ef:	00 00                	add    %al,(%eax)
    98f1:	66 e8 45 fd          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    98f5:	ff                   	(bad)  
    98f6:	ff 66 47             	jmp    *0x47(%esi)
            for (size_t i = 0; i < prog_cnt; ++i) {
    98f9:	66 83 c6 24          	add    $0x24,%si
    98fd:	66 83 c4 0c          	add    $0xc,%sp
    9901:	eb d5                	jmp    98d8 <_ZN2sh4execERKNS_3cmdE+0xac>
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    9903:	66 68 05 bb          	pushw  $0xbb05
    9907:	00 00                	add    %al,(%eax)
    9909:	67 66 8b 06 67 66    	mov    0x6667,%ax
    990f:	ff 74 83 04          	pushl  0x4(%ebx,%eax,4)
    9913:	66 e8 22 f2          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    9917:	ff                   	(bad)  
    9918:	ff 66 5f             	jmp    *0x5f(%esi)
        else if (is_command(input_cmd, "cls") || is_command(input_cmd, "clear"))
    991b:	66 5a                	pop    %dx
    991d:	66 85 c0             	test   %ax,%ax
    9920:	0f 84 90 01 66 68    	je     68669ab6 <_GLOBAL_OFFSET_TABLE_+0x6865dcce>
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    9926:	0b bb 00 00 67 66    	or     0x66670000(%ebx),%edi
    992c:	8b 06                	mov    (%esi),%eax
    992e:	67 66 ff 74 83       	pushw  -0x7d(%si)
    9933:	04 66                	add    $0x66,%al
    9935:	e8 01 f2 ff ff       	call   8b3b <_Z6strcmpPKcS0_>
        else if (is_command(input_cmd, "help"))
    993a:	66 5a                	pop    %dx
    993c:	66 59                	pop    %cx
    993e:	66 85 c0             	test   %ax,%ax
    9941:	75 0c                	jne    994f <_ZN2sh4execERKNS_3cmdE+0x123>
            printf("%s\n", help);
    9943:	66 81 c3 84 09       	add    $0x984,%bx
    9948:	00 00                	add    %al,(%eax)
    994a:	66 53                	push   %bx
    994c:	e9 85 01 66 68       	jmp    68669ad6 <_GLOBAL_OFFSET_TABLE_+0x6865dcee>
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    9951:	14 bb                	adc    $0xbb,%al
    9953:	00 00                	add    %al,(%eax)
    9955:	67 66 8b 06 67 66    	mov    0x6667,%ax
    995b:	ff 74 83 04          	pushl  0x4(%ebx,%eax,4)
    995f:	66 e8 d6 f1          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    9963:	ff                   	(bad)  
    9964:	ff 66 59             	jmp    *0x59(%esi)
        else if (is_command(input_cmd, "echo"))
    9967:	66 5f                	pop    %di
    9969:	66 85 c0             	test   %ax,%ax
    996c:	75 3d                	jne    99ab <_ZN2sh4execERKNS_3cmdE+0x17f>
            for(int i = 1; i < input_cmd.cnt; ++i)
    996e:	66 bf 01 00          	mov    $0x1,%di
    9972:	00 00                	add    %al,(%eax)
    9974:	67 66 39 7e 04       	cmp    %di,0x4(%bp)
    9979:	7e 21                	jle    999c <_ZN2sh4execERKNS_3cmdE+0x170>
                printf("%s ", inputs[input_cmd.start + i]);
    997b:	67 66 8b 06 66 01    	mov    0x166,%ax
    9981:	f8                   	clc    
    9982:	67 66 ff 74 83       	pushw  -0x7d(%si)
    9987:	04 66                	add    $0x66,%al
    9989:	68 19 bb 00 00       	push   $0xbb19
    998e:	66 e8 a8 fc          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9992:	ff                   	(bad)  
    9993:	ff 66 47             	jmp    *0x47(%esi)
            for(int i = 1; i < input_cmd.cnt; ++i)
    9996:	66 58                	pop    %ax
    9998:	66 5a                	pop    %dx
    999a:	eb d8                	jmp    9974 <_ZN2sh4execERKNS_3cmdE+0x148>
            printf("\n");
    999c:	66 68 22 ba          	pushw  $0xba22
    99a0:	00 00                	add    %al,(%eax)
    99a2:	66 e8 94 fc          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    99a6:	ff                   	(bad)  
    99a7:	ff                   	(bad)  
    99a8:	e9 1a 01 66 68       	jmp    68669ac7 <_GLOBAL_OFFSET_TABLE_+0x6865dcdf>
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    99ad:	1d bb 00 00 67       	sbb    $0x670000bb,%eax
    99b2:	66 8b 06             	mov    (%esi),%ax
    99b5:	67 66 ff 74 83       	pushw  -0x7d(%si)
    99ba:	04 66                	add    $0x66,%al
    99bc:	e8 7a f1 ff ff       	call   8b3b <_Z6strcmpPKcS0_>
        else if (is_command(input_cmd, "history"))
    99c1:	66 5a                	pop    %dx
    99c3:	66 59                	pop    %cx
    99c5:	66 85 c0             	test   %ax,%ax
    99c8:	75 2d                	jne    99f7 <_ZN2sh4execERKNS_3cmdE+0x1cb>
    99ca:	67 66 8d b3 04 03    	lea    0x304(%bp,%di),%si
    99d0:	00 00                	add    %al,(%eax)
    99d2:	66 81 c3 84 07       	add    $0x784,%bx
    99d7:	00 00                	add    %al,(%eax)
                printf("%s\n", histroy[i]);
    99d9:	66 56                	push   %si
    99db:	66 68 10 bb          	pushw  $0xbb10
    99df:	00 00                	add    %al,(%eax)
    99e1:	66 e8 55 fc          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    99e5:	ff                   	(bad)  
    99e6:	ff 66 83             	jmp    *-0x7d(%esi)
    99e9:	ee                   	out    %al,(%dx)
    99ea:	80 66 59 66          	andb   $0x66,0x59(%esi)
            for(int i = 1; i < history_term; ++i)
    99ee:	5f                   	pop    %edi
    99ef:	66 39 de             	cmp    %bx,%si
    99f2:	75 e5                	jne    99d9 <_ZN2sh4execERKNS_3cmdE+0x1ad>
    99f4:	e9 01 01 66 68       	jmp    68669afa <_GLOBAL_OFFSET_TABLE_+0x6865dd12>
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    99f9:	25 bb 00 00 67       	and    $0x670000bb,%eax
    99fe:	66 8b 06             	mov    (%esi),%ax
    9a01:	67 66 ff 74 83       	pushw  -0x7d(%si)
    9a06:	04 66                	add    $0x66,%al
    9a08:	e8 2e f1 ff ff       	call   8b3b <_Z6strcmpPKcS0_>
        else if (is_command(input_cmd, "date"))
    9a0d:	66 5f                	pop    %di
    9a0f:	66 5a                	pop    %dx
    9a11:	66 85 c0             	test   %ax,%ax
    9a14:	0f 84 c4 00 66 31    	je     31669ade <_GLOBAL_OFFSET_TABLE_+0x3165dcf6>
            for(size_t i = 0; i < prog_cnt; ++i)
    9a1a:	c9                   	leave  
    9a1b:	67 66 39 8b 84 0b    	cmp    %cx,0xb84(%bp,%di)
    9a21:	00 00                	add    %al,(%eax)
    9a23:	0f 86 a7 00 66 6b    	jbe    6b669ad0 <_GLOBAL_OFFSET_TABLE_+0x6b65dce8>
    9a29:	d1 24 67             	shll   (%edi,%eiz,2)
    9a2c:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    9a30:	67 66 8d bc 13 8c    	lea    -0x73ed(%si),%di
    9a36:	0b 00                	or     (%eax),%eax
    9a38:	00 67 66             	add    %ah,0x66(%edi)
    9a3b:	89 55 f0             	mov    %edx,-0x10(%ebp)
        return (strcmp(inputs[input_cmd.start], cmd_name) == 0);
    9a3e:	66 57                	push   %di
    9a40:	67 66 8b 06 67 66    	mov    0x6667,%ax
    9a46:	ff 74 83 04          	pushl  0x4(%ebx,%eax,4)
    9a4a:	66 e8 eb f0          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    9a4e:	ff                   	(bad)  
    9a4f:	ff 66 5a             	jmp    *0x5a(%esi)
                if (is_command(input_cmd, progs[i].name))
    9a52:	66 59                	pop    %cx
    9a54:	66 85 c0             	test   %ax,%ax
    9a57:	67 66 8b 55 f0       	mov    -0x10(%di),%dx
    9a5c:	67 66 8b 4d ec       	mov    -0x14(%di),%cx
    9a61:	75 66                	jne    9ac9 <_ZN2sh4execERKNS_3cmdE+0x29d>
class bin_loader
{
public:
    static void load_binary_from_floppy(int n)
    {
        sys_read_disk(user_prog_segment, user_prog_load_addr, n, 20);
    9a63:	66 6a 14             	pushw  $0x14
                    bin_loader::load_binary_from_floppy(progs[i].lba);
    9a66:	66 01 d3             	add    %dx,%bx
    9a69:	67 66 0f b7 83 ac 0b 	movzww 0xbac(%bp,%di),%ax
    9a70:	00 00                	add    %al,(%eax)
    9a72:	66 50                	push   %ax
    9a74:	66 68 00 a1          	pushw  $0xa100
    9a78:	00 00                	add    %al,(%eax)
    9a7a:	66 68 00 10          	pushw  $0x1000
    9a7e:	00 00                	add    %al,(%eax)
    9a80:	66 e8 3d ea          	callw  84c1 <sys_get_scancode+0xf>
    9a84:	ff                   	(bad)  
    9a85:	ff 66 83             	jmp    *-0x7d(%esi)
        sys_execve_bin();
    9a88:	c4 10                	les    (%eax),%edx
    9a8a:	66 e8 60 e7          	callw  81ee <sys_bios_getchar+0x5>
    9a8e:	ff                   	(bad)  
    9a8f:	ff 66 57             	jmp    *0x57(%esi)
                    if(!(strlen(progs[i].name) > 2 && progs[i].name[0] == 'c' && progs[i].name[1] == '_'))
    9a92:	66 e8 45 f0          	callw  8adb <_Z6memsetPvim+0x23>
    9a96:	ff                   	(bad)  
    9a97:	ff 66 5e             	jmp    *0x5e(%esi)
    9a9a:	66 83 f8 02          	cmp    $0x2,%ax
    9a9e:	76 14                	jbe    9ab4 <_ZN2sh4execERKNS_3cmdE+0x288>
    9aa0:	67 80 bb 8c 0b 00    	cmpb   $0x0,0xb8c(%bp,%di)
    9aa6:	00 63 75             	add    %ah,0x75(%ebx)
    9aa9:	0a 67 80             	or     -0x80(%edi),%ah
    9aac:	bb 8d 0b 00 00       	mov    $0xb8d,%ebx
    9ab1:	5f                   	pop    %edi
    9ab2:	74 44                	je     9af8 <_ZN2sh4execERKNS_3cmdE+0x2cc>
                        sys_bios_clear_screen();
    9ab4:	66 e8 19 e7          	callw  81d1 <sys_bios_print_string+0x21>
    9ab8:	ff                   	(bad)  
    9ab9:	ff 66 ff             	jmp    *-0x1(%esi)
                        sys_get_current_tty()->tty_init();
    9abc:	36 20 aa 66 e8 2d fc 	and    %ch,%ss:-0x3d2179a(%edx)
    9ac3:	ff                   	(bad)  
    9ac4:	ff 66 59             	jmp    *0x59(%esi)
    9ac7:	eb 2f                	jmp    9af8 <_ZN2sh4execERKNS_3cmdE+0x2cc>
            for(size_t i = 0; i < prog_cnt; ++i)
    9ac9:	66 41                	inc    %cx
    9acb:	e9 4d ff 66 68       	jmp    68679a1d <_GLOBAL_OFFSET_TABLE_+0x6866dc35>
                printf("%s\n", "No such command or file");
    9ad0:	2a bb 00 00 66 68    	sub    0x68660000(%ebx),%bh
    9ad6:	10 bb 00 00 eb 12    	adc    %bh,0x12eb0000(%ebx)
            read_rtc();
    9adc:	66 e8 76 ec          	callw  8756 <_Z16get_RTC_registeri+0x26>
    9ae0:	ff                   	(bad)  
    9ae1:	ff 66 68             	jmp    *0x68(%esi)
            printf("%s", sys_internal_time_str);
    9ae4:	24 aa                	and    $0xaa,%al
    9ae6:	00 00                	add    %al,(%eax)
    9ae8:	66 68 44 bb          	pushw  $0xbb44
    9aec:	00 00                	add    %al,(%eax)
    9aee:	66 e8 48 fb          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9af2:	ff                   	(bad)  
    9af3:	ff 66 58             	jmp    *0x58(%esi)
    9af6:	66 5a                	pop    %dx
    }
    9af8:	66 31 c0             	xor    %ax,%ax
    9afb:	67 66 8d 65 f4       	lea    -0xc(%di),%sp
    9b00:	66 5b                	pop    %bx
    9b02:	66 5e                	pop    %si
    9b04:	66 5f                	pop    %di
    9b06:	66 5d                	pop    %bp
    9b08:	66 c3                	retw   

Disassembly of section .text._ZN2sh16read_prog_recordEv:

00009b0a <_ZN2sh16read_prog_recordEv>:
    void read_prog_record()
    9b0a:	66 55                	push   %bp
    9b0c:	66 89 e5             	mov    %sp,%bp
    9b0f:	66 57                	push   %di
    9b11:	66 56                	push   %si
    9b13:	66 53                	push   %bx
    9b15:	66 83 ec 6c          	sub    $0x6c,%sp
    9b19:	67 66 8b 5d 08       	mov    0x8(%di),%bx
        sys_read_disk(0, (uint32_t)record_buf, REC_FILE_SECTOR, 1);
    9b1e:	67 66 8d bb 84 07    	lea    0x784(%bp,%di),%di
    9b24:	00 00                	add    %al,(%eax)
    9b26:	66 6a 01             	pushw  $0x1
    9b29:	66 6a 54             	pushw  $0x54
    9b2c:	66 57                	push   %di
    9b2e:	66 6a 00             	pushw  $0x0
    9b31:	66 e8 8c e9          	callw  84c1 <sys_get_scancode+0xf>
    9b35:	ff                   	(bad)  
    9b36:	ff 66 83             	jmp    *-0x7d(%esi)
        sscanf(p, "%s", buf1);
    9b39:	c4 10                	les    (%eax),%edx
    9b3b:	67 66 8d 75 94       	lea    -0x6c(%di),%si
    9b40:	66 56                	push   %si
    9b42:	66 68 44 bb          	pushw  $0xbb44
    9b46:	00 00                	add    %al,(%eax)
    9b48:	66 57                	push   %di
    9b4a:	66 e8 c2 f8          	callw  9410 <_Z7vsscanfPKcS0_Pc+0x1bf>
    9b4e:	ff                   	(bad)  
    9b4f:	ff 66 83             	jmp    *-0x7d(%esi)
        p += (strlen(buf1) + 1);
    9b52:	c4 0c 66             	les    (%esi,%eiz,2),%ecx
    9b55:	56                   	push   %esi
    9b56:	66 e8 81 ef          	callw  8adb <_Z6memsetPvim+0x23>
    9b5a:	ff                   	(bad)  
    9b5b:	ff 67 66             	jmp    *0x66(%edi)
    9b5e:	8d 44 07 01          	lea    0x1(%edi,%eax,1),%eax
    9b62:	67 66 89 45 8c       	mov    %ax,-0x74(%di)
        prog_cnt = strtol(buf1, nullptr, 10);
    9b67:	67 66 c7 04 24 0a    	movw   $0xa24,(%si)
    9b6d:	00 00                	add    %al,(%eax)
    9b6f:	00 66 6a             	add    %ah,0x6a(%esi)
    9b72:	00 66 56             	add    %ah,0x56(%esi)
    9b75:	66 e8 0e f4          	callw  8f87 <_Z4ldivll+0xa9>
    9b79:	ff                   	(bad)  
    9b7a:	ff 67 66             	jmp    *0x66(%edi)
    9b7d:	89 83 84 0b 00 00    	mov    %eax,0xb84(%ebx)
    9b83:	66 83 c4 0c          	add    $0xc,%sp
        for(size_t i = 0; i < prog_cnt; ++i)
    9b87:	67 66 c7 45 90 00 00 	movw   $0x0,-0x70(%di)
    9b8e:	00 00                	add    %al,(%eax)
    9b90:	67 66 8b 45 90       	mov    -0x70(%di),%ax
    9b95:	67 66 39 83 84 0b    	cmp    %ax,0xb84(%bp,%di)
    9b9b:	00 00                	add    %al,(%eax)
    9b9d:	0f 86 97 00 67 66    	jbe    66679c3a <_GLOBAL_OFFSET_TABLE_+0x6666de52>
            sscanf(p, "%s%s", buf2, buf3);
    9ba3:	8d 7d d4             	lea    -0x2c(%ebp),%edi
    9ba6:	66 57                	push   %di
    9ba8:	67 66 8d 75 b4       	lea    -0x4c(%di),%si
    9bad:	66 56                	push   %si
    9baf:	66 68 42 bb          	pushw  $0xbb42
    9bb3:	00 00                	add    %al,(%eax)
    9bb5:	67 66 ff 75 8c       	pushw  -0x74(%di)
    9bba:	66 e8 52 f8          	callw  9410 <_Z7vsscanfPKcS0_Pc+0x1bf>
    9bbe:	ff                   	(bad)  
    9bbf:	ff 67 66             	jmp    *0x66(%edi)
    9bc2:	6b 4d 90 24          	imul   $0x24,-0x70(%ebp),%ecx
            strcpy(progs[i].name, buf2);
    9bc6:	66 83 c4 10          	add    $0x10,%sp
    9bca:	66 56                	push   %si
    9bcc:	67 66 8d 84 0b 8c    	lea    -0x73f5(%si),%ax
    9bd2:	0b 00                	or     (%eax),%eax
    9bd4:	00 67 66             	add    %ah,0x66(%edi)
    9bd7:	89 4d 88             	mov    %ecx,-0x78(%ebp)
    9bda:	66 50                	push   %ax
    9bdc:	66 e8 17 ef          	callw  8af7 <_Z6strlenPKc+0x1a>
    9be0:	ff                   	(bad)  
    9be1:	ff 66 58             	jmp    *0x58(%esi)
            progs[i].lba = strtol(buf3, nullptr, 10);
    9be4:	66 5a                	pop    %dx
    9be6:	66 6a 0a             	pushw  $0xa
    9be9:	66 6a 00             	pushw  $0x0
    9bec:	66 57                	push   %di
    9bee:	66 e8 95 f3          	callw  8f87 <_Z4ldivll+0xa9>
    9bf2:	ff                   	(bad)  
    9bf3:	ff 67 66             	jmp    *0x66(%edi)
    9bf6:	8b 4d 88             	mov    -0x78(%ebp),%ecx
    9bf9:	67 66 89 84 0b ac    	mov    %ax,-0x53f5(%si)
    9bff:	0b 00                	or     (%eax),%eax
    9c01:	00 66 83             	add    %ah,-0x7d(%esi)
            p += (strlen(buf2) + strlen(buf3) + 2);
    9c04:	c4 0c 66             	les    (%esi,%eiz,2),%ecx
    9c07:	56                   	push   %esi
    9c08:	66 e8 cf ee          	callw  8adb <_Z6memsetPvim+0x23>
    9c0c:	ff                   	(bad)  
    9c0d:	ff 67 66             	jmp    *0x66(%edi)
    9c10:	89 45 88             	mov    %eax,-0x78(%ebp)
    9c13:	67 66 89 3c          	mov    %di,(%si)
    9c17:	24 66                	and    $0x66,%al
    9c19:	e8 bf ee ff ff       	call   8add <_Z6strlenPKc>
    9c1e:	67 66 8b 55 88       	mov    -0x78(%di),%dx
    9c23:	67 66 8d 44 02       	lea    0x2(%si),%ax
    9c28:	02 67 66             	add    0x66(%edi),%ah
    9c2b:	01 45 8c             	add    %eax,-0x74(%ebp)
        for(size_t i = 0; i < prog_cnt; ++i)
    9c2e:	67 66 ff 45 90       	incw   -0x70(%di)
    9c33:	66 59                	pop    %cx
    9c35:	e9 58 ff 67 66       	jmp    66689b92 <_GLOBAL_OFFSET_TABLE_+0x6667ddaa>
    }
    9c3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    9c3d:	66 5b                	pop    %bx
    9c3f:	66 5e                	pop    %si
    9c41:	66 5f                	pop    %di
    9c43:	66 5d                	pop    %bp
    9c45:	66 c3                	retw   

Disassembly of section .text._ZN2sh3runEv:

00009c48 <_ZN2sh3runEv>:
        read_help_file();
    }
    void run () {
    9c48:	66 55                	push   %bp
    9c4a:	66 89 e5             	mov    %sp,%bp
    9c4d:	66 57                	push   %di
    9c4f:	66 56                	push   %si
    9c51:	66 53                	push   %bx
    9c53:	66 83 ec 10          	sub    $0x10,%sp
    9c57:	67 66 8b 7d 08       	mov    0x8(%di),%di
        printf("%s", prompt);
    9c5c:	66 68 47 bb          	pushw  $0xbb47
    9c60:	00 00                	add    %al,(%eax)
    9c62:	66 68 44 bb          	pushw  $0xbb44
    9c66:	00 00                	add    %al,(%eax)
    9c68:	66 e8 ce f9          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9c6c:	ff                   	(bad)  
    9c6d:	ff 66 59             	jmp    *0x59(%esi)
    9c70:	66 5b                	pop    %bx
        while(true)
        {
            char in = getchar();
    9c72:	66 e8 71 f5          	callw  91e7 <_Z4putsPKc+0x3c>
    9c76:	ff                   	(bad)  
    9c77:	ff 66 89             	jmp    *-0x77(%esi)
    9c7a:	c2 3c 08             	ret    $0x83c
            if (in == '\b')
    9c7d:	75 35                	jne    9cb4 <_ZN2sh3runEv+0x6c>
            {
                if(pos != 0){
    9c7f:	67 66 83 bf 88 0b 00 	cmpw   $0x0,0xb88(%bx)
    9c86:	00 00                	add    %al,(%eax)
    9c88:	74 e8                	je     9c72 <_ZN2sh3runEv+0x2a>
                    putchar('\b');
    9c8a:	66 6a 08             	pushw  $0x8
    9c8d:	66 e8 fe f4          	callw  918f <_ZL19system_call_putchari+0x29>
    9c91:	ff                   	(bad)  
    9c92:	ff 67 66             	jmp    *0x66(%edi)
                    buf[pos--] = '\0';
    9c95:	8b 87 88 0b 00 00    	mov    0xb88(%edi),%eax
    9c9b:	67 66 8d 50 ff       	lea    -0x1(%bx,%si),%dx
    9ca0:	67 66 89 97 88 0b    	mov    %dx,0xb88(%bx)
    9ca6:	00 00                	add    %al,(%eax)
    9ca8:	67 c6 84 07 04 02    	movb   $0x2,0x407(%si)
    9cae:	00 00                	add    %al,(%eax)
    9cb0:	00 e9                	add    %ch,%cl
    9cb2:	03 03                	add    (%ebx),%eax
                }
            }
            else if (in == 13)
    9cb4:	3c 0d                	cmp    $0xd,%al
    9cb6:	0f 85 d8 01 66 6a    	jne    6a669e94 <_GLOBAL_OFFSET_TABLE_+0x6a65e0ac>
            {
                putchar('\n');
    9cbc:	0a 66 e8             	or     -0x18(%esi),%ah
    9cbf:	ce                   	into   
    9cc0:	f4                   	hlt    
    9cc1:	ff                   	(bad)  
    9cc2:	ff 67 66             	jmp    *0x66(%edi)
                if(strlen(buf) == 0)
    9cc5:	8d 87 04 02 00 00    	lea    0x204(%edi),%eax
    9ccb:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
    9cd0:	67 66 89 04          	mov    %ax,(%si)
    9cd4:	24 66                	and    $0x66,%al
    9cd6:	e8 02 ee ff ff       	call   8add <_Z6strlenPKc>
    9cdb:	66 5a                	pop    %dx
    9cdd:	66 85 c0             	test   %ax,%ax
    9ce0:	0f 84 78 ff 67 66    	je     66689c5e <_GLOBAL_OFFSET_TABLE_+0x6667de76>
        memmove(histroy[1], histroy[0], buf_size * history_term * sizeof(char));
    9ce6:	8d 9f 84 02 00 00    	lea    0x284(%edi),%ebx
    9cec:	66 68 00 05          	pushw  $0x500
    9cf0:	00 00                	add    %al,(%eax)
    9cf2:	66 53                	push   %bx
    9cf4:	67 66 8d 87 04 03    	lea    0x304(%bx),%ax
    9cfa:	00 00                	add    %al,(%eax)
    9cfc:	66 50                	push   %ax
    9cfe:	66 e8 67 ed          	callw  8a69 <_Z6memcpyPvPKvm+0x2b>
    9d02:	ff                   	(bad)  
    9d03:	ff 66 83             	jmp    *-0x7d(%esi)
        strcpy(histroy[0], buf);
    9d06:	c4 0c 67             	les    (%edi,%eiz,2),%ecx
    9d09:	66 ff 75 f0          	pushw  -0x10(%ebp)
    9d0d:	66 53                	push   %bx
    9d0f:	66 e8 e4 ed          	callw  8af7 <_Z6strlenPKc+0x1a>
    9d13:	ff                   	(bad)  
    9d14:	ff 66 5b             	jmp    *0x5b(%esi)
    9d17:	66 5e                	pop    %si
        char * p = buf;
    9d19:	67 66 8d 9f 04 02    	lea    0x204(%bx),%bx
    9d1f:	00 00                	add    %al,(%eax)
        while(*p && isspace(*p)){
    9d21:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    9d26:	84 c0                	test   %al,%al
    9d28:	75 08                	jne    9d32 <_ZN2sh3runEv+0xea>
        char * p = buf;
    9d2a:	66 31 d2             	xor    %dx,%dx
    9d2d:	66 31 f6             	xor    %si,%si
    9d30:	eb 39                	jmp    9d6b <_ZN2sh3runEv+0x123>
        while(*p && isspace(*p)){
    9d32:	66 50                	push   %ax
    9d34:	66 e8 ba ee          	callw  8bf2 <_Z7reversePc+0x4a>
    9d38:	ff                   	(bad)  
    9d39:	ff 66 59             	jmp    *0x59(%esi)
    9d3c:	66 85 c0             	test   %ax,%ax
    9d3f:	74 e9                	je     9d2a <_ZN2sh3runEv+0xe2>
            ++p;
    9d41:	66 43                	inc    %bx
    9d43:	eb dc                	jmp    9d21 <_ZN2sh3runEv+0xd9>
    9d45:	67 88 55 ec          	mov    %dl,-0x14(%di)
            if(isspace(*p))
    9d49:	66 50                	push   %ax
    9d4b:	66 e8 a3 ee          	callw  8bf2 <_Z7reversePc+0x4a>
    9d4f:	ff                   	(bad)  
    9d50:	ff 66 5a             	jmp    *0x5a(%esi)
    9d53:	66 85 c0             	test   %ax,%ax
    9d56:	67 8a 55 ec          	mov    -0x14(%di),%dl
    9d5a:	74 1a                	je     9d76 <_ZN2sh3runEv+0x12e>
                *p = '\0';
    9d5c:	67 c6 03 00          	movb   $0x0,(%bp,%di)
                if(con)
    9d60:	84 d2                	test   %dl,%dl
    9d62:	74 05                	je     9d69 <_ZN2sh3runEv+0x121>
                    ++i;
    9d64:	66 46                	inc    %si
                    con = false;
    9d66:	66 31 d2             	xor    %dx,%dx
            ++p;
    9d69:	66 43                	inc    %bx
        while (*p)
    9d6b:	67 66 0f be 03       	movsbw (%bp,%di),%ax
    9d70:	84 c0                	test   %al,%al
    9d72:	75 d1                	jne    9d45 <_ZN2sh3runEv+0xfd>
    9d74:	eb 0e                	jmp    9d84 <_ZN2sh3runEv+0x13c>
                if(!con)
    9d76:	84 d2                	test   %dl,%dl
    9d78:	75 ef                	jne    9d69 <_ZN2sh3runEv+0x121>
                    inputs[i] = p;
    9d7a:	67 66 89 5c b7       	mov    %bx,-0x49(%si)
    9d7f:	04 b2                	add    $0xb2,%al
                    con = true;
    9d81:	01 eb                	add    %ebp,%ebx
    9d83:	e5 84                	in     $0x84,%eax
        if(con) ++i;
    9d85:	d2 74 04 66          	shlb   %cl,0x66(%esp,%eax,1)
    9d89:	46                   	inc    %esi
    9d8a:	eb 07                	jmp    9d93 <_ZN2sh3runEv+0x14b>
                    printf("%s", prompt);
                    continue;
                }
                history_push(buf);
                int input_cnt = split_input(buf);
                if (input_cnt == 0)
    9d8c:	66 85 f6             	test   %si,%si
    9d8f:	0f 84 df fe 67 66    	je     66689c74 <_GLOBAL_OFFSET_TABLE_+0x6667de8c>
                    continue;
                int cmd_cnt = split_batch(inputs, input_cnt);
    9d95:	8d 47 04             	lea    0x4(%edi),%eax
    9d98:	67 66 89 45 ec       	mov    %ax,-0x14(%di)
        int p = 0;
    9d9d:	66 31 c9             	xor    %cx,%cx
        while(strcmp(inputs[p], ";") == 0){
    9da0:	66 68 4e bb          	pushw  $0xbb4e
    9da4:	00 00                	add    %al,(%eax)
    9da6:	67 66 8b 45 ec       	mov    -0x14(%di),%ax
    9dab:	67 66 ff 34          	pushw  (%si)
    9daf:	88 67 66             	mov    %ah,0x66(%edi)
    9db2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    9db5:	66 e8 80 ed          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    9db9:	ff                   	(bad)  
    9dba:	ff 66 59             	jmp    *0x59(%esi)
    9dbd:	66 5b                	pop    %bx
    9dbf:	66 85 c0             	test   %ax,%ax
    9dc2:	67 66 8b 4d e8       	mov    -0x18(%di),%cx
    9dc7:	75 04                	jne    9dcd <_ZN2sh3runEv+0x185>
            ++p;
    9dc9:	66 41                	inc    %cx
    9dcb:	eb d3                	jmp    9da0 <_ZN2sh3runEv+0x158>
        bool con = false;
    9dcd:	66 31 d2             	xor    %dx,%dx
        int i = 0;
    9dd0:	66 31 db             	xor    %bx,%bx
        while (p < input_cnt)
    9dd3:	66 39 f1             	cmp    %si,%cx
    9dd6:	7d 6a                	jge    9e42 <_ZN2sh3runEv+0x1fa>
    9dd8:	67 88 55 e7          	mov    %dl,-0x19(%di)
            if(strcmp(inputs[p], ";") == 0)
    9ddc:	66 68 4e bb          	pushw  $0xbb4e
    9de0:	00 00                	add    %al,(%eax)
    9de2:	67 66 8b 45 ec       	mov    -0x14(%di),%ax
    9de7:	67 66 ff 34          	pushw  (%si)
    9deb:	88 67 66             	mov    %ah,0x66(%edi)
    9dee:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    9df1:	66 e8 44 ed          	callw  8b39 <_Z6strcpyPcPKc+0x40>
    9df5:	ff                   	(bad)  
    9df6:	ff 66 59             	jmp    *0x59(%esi)
    9df9:	66 5a                	pop    %dx
    9dfb:	66 85 c0             	test   %ax,%ax
    9dfe:	67 66 8b 4d e8       	mov    -0x18(%di),%cx
    9e03:	67 8a 55 e7          	mov    -0x19(%di),%dl
    9e07:	75 0b                	jne    9e14 <_ZN2sh3runEv+0x1cc>
                if(con)
    9e09:	84 d2                	test   %dl,%dl
    9e0b:	74 31                	je     9e3e <_ZN2sh3runEv+0x1f6>
                    ++i;
    9e0d:	66 43                	inc    %bx
                    con = false;
    9e0f:	66 31 d2             	xor    %dx,%dx
    9e12:	eb 2a                	jmp    9e3e <_ZN2sh3runEv+0x1f6>
                if(!con)
    9e14:	84 d2                	test   %dl,%dl
    9e16:	75 1d                	jne    9e35 <_ZN2sh3runEv+0x1ed>
    9e18:	67 66 8d 04          	lea    (%si),%ax
    9e1c:	df 67 66             	fbld   0x66(%edi)
                    cmds[i].start = p;
    9e1f:	89 88 04 01 00 00    	mov    %ecx,0x104(%eax)
                    cmds[i].cnt = 1;
    9e25:	67 66 c7 80 08 01 00 	movw   $0x0,0x108(%bx,%si)
    9e2c:	00 
    9e2d:	01 00                	add    %eax,(%eax)
    9e2f:	00 00                	add    %al,(%eax)
                    con = true;
    9e31:	b2 01                	mov    $0x1,%dl
    9e33:	eb 09                	jmp    9e3e <_ZN2sh3runEv+0x1f6>
                    cmds[i].cnt++;
    9e35:	67 66 ff 84 df 08    	incw   0x8df(%si)
    9e3b:	01 00                	add    %eax,(%eax)
    9e3d:	00 66 41             	add    %ah,0x41(%esi)
            ++p;
    9e40:	eb 91                	jmp    9dd3 <_ZN2sh3runEv+0x18b>
        if(con) ++i;
    9e42:	84 d2                	test   %dl,%dl
    9e44:	74 02                	je     9e48 <_ZN2sh3runEv+0x200>
    9e46:	66 43                	inc    %bx
                for(int cmd_num = 0; cmd_num < cmd_cnt; ++ cmd_num)
    9e48:	66 31 f6             	xor    %si,%si
    9e4b:	66 39 de             	cmp    %bx,%si
    9e4e:	74 1b                	je     9e6b <_ZN2sh3runEv+0x223>
                {
                    exec(cmds[cmd_num]);
    9e50:	67 66 8d 84 f7 04    	lea    0x4f7(%si),%ax
    9e56:	01 00                	add    %eax,(%eax)
    9e58:	00 66 50             	add    %ah,0x50(%esi)
    9e5b:	66 57                	push   %di
    9e5d:	66 e8 c9 f9          	callw  982a <_ZN3tty7putcharEi+0x100>
    9e61:	ff                   	(bad)  
    9e62:	ff 66 46             	jmp    *0x46(%esi)
                for(int cmd_num = 0; cmd_num < cmd_cnt; ++ cmd_num)
    9e65:	66 58                	pop    %ax
    9e67:	66 5a                	pop    %dx
    9e69:	eb e0                	jmp    9e4b <_ZN2sh3runEv+0x203>
                }
                memset(buf, 0, buf_size);
    9e6b:	66 68 80 00          	pushw  $0x80
    9e6f:	00 00                	add    %al,(%eax)
    9e71:	66 6a 00             	pushw  $0x0
    9e74:	67 66 ff 75 f0       	pushw  -0x10(%di)
    9e79:	66 e8 39 ec          	callw  8ab6 <_Z7memmovePvPKvm+0x4b>
    9e7d:	ff                   	(bad)  
    9e7e:	ff 67 66             	jmp    *0x66(%edi)
                pos = 0;
    9e81:	c7 87 88 0b 00 00 00 	movl   $0x0,0xb88(%edi)
    9e88:	00 00 00 
                printf("%s", prompt);
    9e8b:	66 83 c4 0c          	add    $0xc,%sp
    9e8f:	e9 ca fd 84 c0       	jmp    c0859c5e <_GLOBAL_OFFSET_TABLE_+0xc084de76>
            }
            else if (in == 0)
    9e94:	0f 84 da fd 3c 09    	je     93d9c74 <_GLOBAL_OFFSET_TABLE_+0x93cde8c>
            {
                continue;
            }
            else if( in == '\t')
    9e9a:	0f 85 e6 00 66 31    	jne    31669f86 <_GLOBAL_OFFSET_TABLE_+0x3165e19e>
            {
                bool first_matching = false;
                for(int i = 0; i < supported_cmd_num; ++i){
    9ea0:	db 66 31             	(bad)  0x31(%esi)
                bool first_matching = false;
    9ea3:	c9                   	leave  
    9ea4:	67 66 8d b7 04 02    	lea    0x204(%bx),%si
    9eaa:	00 00                	add    %al,(%eax)
                for(int i = 0; i < supported_cmd_num; ++i){
    9eac:	67 66 39 1f          	cmp    %bx,(%bx)
    9eb0:	7e 53                	jle    9f05 <_ZN2sh3runEv+0x2bd>
    9eb2:	67 88 4d ec          	mov    %cl,-0x14(%di)
                    if(bf(buf, cmd_list[i]) != -1)
    9eb6:	67 66 8b 04          	mov    (%si),%ax
    9eba:	9d                   	popf   
    9ebb:	60                   	pusha  
    9ebc:	bb 00 00 67 66       	mov    $0x66670000,%ebx
    9ec1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9ec4:	66 89 c2             	mov    %ax,%dx
    9ec7:	66 89 f0             	mov    %si,%ax
    9eca:	66 e8 aa f7          	callw  9678 <_Z6printfPKcz+0x3c>
    9ece:	ff                   	(bad)  
    9ecf:	ff 66 40             	jmp    *0x40(%esi)
    9ed2:	67 8a 4d ec          	mov    -0x14(%di),%cl
    9ed6:	74 29                	je     9f01 <_ZN2sh3runEv+0x2b9>
                    {
                        if(!first_matching){
    9ed8:	84 c9                	test   %cl,%cl
    9eda:	75 0e                	jne    9eea <_ZN2sh3runEv+0x2a2>
                            printf("\n");
    9edc:	66 68 22 ba          	pushw  $0xba22
    9ee0:	00 00                	add    %al,(%eax)
    9ee2:	66 e8 54 f7          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9ee6:	ff                   	(bad)  
    9ee7:	ff 66 58             	jmp    *0x58(%esi)
                            first_matching = true;
                        }
                        printf("%s\n", cmd_list[i]);
    9eea:	67 66 ff 75 f0       	pushw  -0x10(%di)
    9eef:	66 68 10 bb          	pushw  $0xbb10
    9ef3:	00 00                	add    %al,(%eax)
    9ef5:	66 e8 41 f7          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9ef9:	ff                   	(bad)  
    9efa:	ff 66 5e             	jmp    *0x5e(%esi)
    9efd:	66 58                	pop    %ax
    9eff:	b1 01                	mov    $0x1,%cl
                for(int i = 0; i < supported_cmd_num; ++i){
    9f01:	66 43                	inc    %bx
    9f03:	eb 9f                	jmp    9ea4 <_ZN2sh3runEv+0x25c>
                    }
                }
                for(size_t i = 0; i < prog_cnt; ++i)
    9f05:	66 31 db             	xor    %bx,%bx
    9f08:	67 88 4d ec          	mov    %cl,-0x14(%di)
    9f0c:	67 66 39 9f 84 0b    	cmp    %bx,0xb84(%bx)
    9f12:	00 00                	add    %al,(%eax)
    9f14:	76 53                	jbe    9f69 <_ZN2sh3runEv+0x321>
    9f16:	66 6b c3 24          	imul   $0x24,%bx,%ax
    9f1a:	67 66 8d 84 07 8c    	lea    -0x73f9(%si),%ax
    9f20:	0b 00                	or     (%eax),%eax
    9f22:	00 67 66             	add    %ah,0x66(%edi)
    9f25:	89 45 f0             	mov    %eax,-0x10(%ebp)
                    if(bf(buf, progs[i].name) != -1)
    9f28:	66 89 c2             	mov    %ax,%dx
    9f2b:	66 89 f0             	mov    %si,%ax
    9f2e:	66 e8 46 f7          	callw  9678 <_Z6printfPKcz+0x3c>
    9f32:	ff                   	(bad)  
    9f33:	ff 66 40             	jmp    *0x40(%esi)
    9f36:	67 8a 4d ec          	mov    -0x14(%di),%cl
    9f3a:	74 29                	je     9f65 <_ZN2sh3runEv+0x31d>
                    {
                        if(!first_matching){
    9f3c:	84 c9                	test   %cl,%cl
    9f3e:	75 0e                	jne    9f4e <_ZN2sh3runEv+0x306>
                            printf("\n");
    9f40:	66 68 22 ba          	pushw  $0xba22
    9f44:	00 00                	add    %al,(%eax)
    9f46:	66 e8 f0 f6          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9f4a:	ff                   	(bad)  
    9f4b:	ff 66 59             	jmp    *0x59(%esi)
                            first_matching = true;
                        }
                        printf("%s\n", progs[i].name);
    9f4e:	67 66 ff 75 f0       	pushw  -0x10(%di)
    9f53:	66 68 10 bb          	pushw  $0xbb10
    9f57:	00 00                	add    %al,(%eax)
    9f59:	66 e8 dd f6          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9f5d:	ff                   	(bad)  
    9f5e:	ff 66 58             	jmp    *0x58(%esi)
    9f61:	66 5a                	pop    %dx
    9f63:	b1 01                	mov    $0x1,%cl
                for(size_t i = 0; i < prog_cnt; ++i)
    9f65:	66 43                	inc    %bx
    9f67:	eb 9f                	jmp    9f08 <_ZN2sh3runEv+0x2c0>
                    }
                printf("%s", prompt);
    9f69:	66 68 47 bb          	pushw  $0xbb47
    9f6d:	00 00                	add    %al,(%eax)
    9f6f:	66 68 44 bb          	pushw  $0xbb44
    9f73:	00 00                	add    %al,(%eax)
    9f75:	66 e8 c1 f6          	callw  963a <_Z7sprintfPcPKcz+0x1e>
    9f79:	ff                   	(bad)  
    9f7a:	ff 66 5a             	jmp    *0x5a(%esi)
                printf("%s", buf);
    9f7d:	66 59                	pop    %cx
    9f7f:	66 56                	push   %si
    9f81:	e9 de fc 66 0f       	jmp    f679c64 <_GLOBAL_OFFSET_TABLE_+0xf66de7c>
            }
            else {
                putchar(in);
    9f86:	be c0 67 66 89       	mov    $0x896667c0,%esi
    9f8b:	55                   	push   %ebp
    9f8c:	f0 66 50             	lock push %ax
    9f8f:	66 e8 fc f1          	callw  918f <_ZL19system_call_putchari+0x29>
    9f93:	ff                   	(bad)  
    9f94:	ff 67 66             	jmp    *0x66(%edi)
                buf[pos++] = in;
    9f97:	8b 87 88 0b 00 00    	mov    0xb88(%edi),%eax
    9f9d:	67 66 8d 48 01       	lea    0x1(%bx,%si),%cx
    9fa2:	67 66 89 8f 88 0b    	mov    %cx,0xb88(%bx)
    9fa8:	00 00                	add    %al,(%eax)
    9faa:	67 66 8b 55 f0       	mov    -0x10(%di),%dx
    9faf:	67 88 94 07 04       	mov    %dl,0x407(%si)
    9fb4:	02 00                	add    (%eax),%al
    9fb6:	00 66 58             	add    %ah,0x58(%esi)
    9fb9:	e9                   	.byte 0xe9
    9fba:	b6 fc                	mov    $0xfc,%dh

Disassembly of section .text._Z4itoaIjEvPcT_ib:

00009fbc <_Z4itoaIjEvPcT_ib>:
void itoa(char* buffer, T num, int base, bool captial = false)
    9fbc:	66 55                	push   %bp
    9fbe:	66 89 e5             	mov    %sp,%bp
    9fc1:	66 57                	push   %di
    9fc3:	66 56                	push   %si
    9fc5:	66 53                	push   %bx
    9fc7:	66 83 ec 08          	sub    $0x8,%sp
    9fcb:	67 66 8b 75 08       	mov    0x8(%di),%si
    9fd0:	67 66 8b 45 0c       	mov    0xc(%di),%ax
    9fd5:	67 66 8b 7d 10       	mov    0x10(%di),%di
    9fda:	67 8a 5d 14          	mov    0x14(%di),%bl
    9fde:	67 88 5d ef          	mov    %bl,-0x11(%di)
    char *p = buffer;
    9fe2:	66 89 f1             	mov    %si,%cx
    9fe5:	66 31 d2             	xor    %dx,%dx
    9fe8:	66 f7 f7             	div    %di
    9feb:	67 66 89 45 f0       	mov    %ax,-0x10(%di)
        *(p++) = captial ? num_char_upper[mod] : num_char_lower[mod];
    9ff0:	67 80 7d ef 00       	cmpb   $0x0,-0x11(%di)
    9ff5:	74 09                	je     a000 <_Z4itoaIjEvPcT_ib+0x44>
    9ff7:	67 8a 9a c4 bd       	mov    -0x423c(%bp,%si),%bl
    9ffc:	00 00                	add    %al,(%eax)
    9ffe:	eb 07                	jmp    a007 <_Z4itoaIjEvPcT_ib+0x4b>
    a000:	67 8a 9a d5 bd       	mov    -0x422b(%bp,%si),%bl
    a005:	00 00                	add    %al,(%eax)
    a007:	67 66 8d 51 01       	lea    0x1(%bx,%di),%dx
    a00c:	67 88 5a ff          	mov    %bl,-0x1(%bp,%si)
        if(num == 0) break;
    a010:	67 66 83 7d f0 00    	cmpw   $0x0,-0x10(%di)
    a016:	74 05                	je     a01d <_Z4itoaIjEvPcT_ib+0x61>
    a018:	66 89 d1             	mov    %dx,%cx
    a01b:	eb c8                	jmp    9fe5 <_Z4itoaIjEvPcT_ib+0x29>
    *p = '\0';
    a01d:	67 c6 41 01 00       	movb   $0x0,0x1(%bx,%di)
    reverse(buffer);
    a022:	67 66 89 75 08       	mov    %si,0x8(%di)
}
    a027:	66 58                	pop    %ax
    a029:	66 5a                	pop    %dx
    a02b:	66 5b                	pop    %bx
    a02d:	66 5e                	pop    %si
    a02f:	66 5f                	pop    %di
    a031:	66 5d                	pop    %bp
    reverse(buffer);
    a033:	e9                   	.byte 0xe9
    a034:	72 eb                	jb     a021 <_Z4itoaIjEvPcT_ib+0x65>
